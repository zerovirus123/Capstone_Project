
SD_PCR_v2.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         0000018e  00800100  00001c4c  00001ce0  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00001c4c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000082  0080028e  0080028e  00001e6e  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00001e6e  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00001ea0  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000118  00000000  00000000  00001ee0  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00001507  00000000  00000000  00001ff8  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 0000067f  00000000  00000000  000034ff  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000974  00000000  00000000  00003b7e  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000002c4  00000000  00000000  000044f4  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000003dc  00000000  00000000  000047b8  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00000e91  00000000  00000000  00004b94  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000000e0  00000000  00000000  00005a25  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 56 00 	jmp	0xac	; 0xac <__ctors_end>
       4:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
       8:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
       c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      10:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      14:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      18:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      1c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      20:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      24:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      28:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      2c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      30:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      34:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      38:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      3c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      40:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      44:	0c 94 d5 06 	jmp	0xdaa	; 0xdaa <__vector_17>
      48:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      4c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      50:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      54:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      58:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      5c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      60:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      64:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      68:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      6c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      70:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      74:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      78:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      7c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      80:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      84:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      88:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      8c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      90:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      94:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      98:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      9c:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      a0:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      a4:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>
      a8:	0c 94 73 00 	jmp	0xe6	; 0xe6 <__bad_interrupt>

000000ac <__ctors_end>:
      ac:	11 24       	eor	r1, r1
      ae:	1f be       	out	0x3f, r1	; 63
      b0:	cf ef       	ldi	r28, 0xFF	; 255
      b2:	da e0       	ldi	r29, 0x0A	; 10
      b4:	de bf       	out	0x3e, r29	; 62
      b6:	cd bf       	out	0x3d, r28	; 61

000000b8 <__do_copy_data>:
      b8:	12 e0       	ldi	r17, 0x02	; 2
      ba:	a0 e0       	ldi	r26, 0x00	; 0
      bc:	b1 e0       	ldi	r27, 0x01	; 1
      be:	ec e4       	ldi	r30, 0x4C	; 76
      c0:	fc e1       	ldi	r31, 0x1C	; 28
      c2:	02 c0       	rjmp	.+4      	; 0xc8 <__do_copy_data+0x10>
      c4:	05 90       	lpm	r0, Z+
      c6:	0d 92       	st	X+, r0
      c8:	ae 38       	cpi	r26, 0x8E	; 142
      ca:	b1 07       	cpc	r27, r17
      cc:	d9 f7       	brne	.-10     	; 0xc4 <__do_copy_data+0xc>

000000ce <__do_clear_bss>:
      ce:	23 e0       	ldi	r18, 0x03	; 3
      d0:	ae e8       	ldi	r26, 0x8E	; 142
      d2:	b2 e0       	ldi	r27, 0x02	; 2
      d4:	01 c0       	rjmp	.+2      	; 0xd8 <.do_clear_bss_start>

000000d6 <.do_clear_bss_loop>:
      d6:	1d 92       	st	X+, r1

000000d8 <.do_clear_bss_start>:
      d8:	a0 31       	cpi	r26, 0x10	; 16
      da:	b2 07       	cpc	r27, r18
      dc:	e1 f7       	brne	.-8      	; 0xd6 <.do_clear_bss_loop>
      de:	0e 94 c7 0a 	call	0x158e	; 0x158e <main>
      e2:	0c 94 24 0e 	jmp	0x1c48	; 0x1c48 <_exit>

000000e6 <__bad_interrupt>:
      e6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000ea <adc_init>:
	4 - ADC4D -> F4
	5 - ADC5D -> F5
	6 - ADC6D -> F6
	7 - ADC7D -> F7	 
	*/
	DIDR0 = 0x01;  // 00000001 is the binary equivalent of 0x01. Setting the register to 00010011 disables digital input, making the pin an analog pin. ADC pin 0 is F0.
      ea:	81 e0       	ldi	r24, 0x01	; 1
      ec:	80 93 7e 00 	sts	0x007E, r24
	Bits 4:0 – MUX4:0: Analog Channel Selection Bits (See p.308 of data sheet for table)  
	The value of these bits selects which combination of analog inputs are connected to the ADC.
	These bits also select the gain for the differential channels. If these bits are changed during a conversion, 
	the change will not go in effect until this conversion is complete (ADIF in ADCSRA is set).
	*/	
	ADMUX |= (1 << REFS0); // 01000000 sets the register to keep right adjust on, and selects ADC0 and only input channel. 
      f0:	ec e7       	ldi	r30, 0x7C	; 124
      f2:	f0 e0       	ldi	r31, 0x00	; 0
      f4:	80 81       	ld	r24, Z
      f6:	80 64       	ori	r24, 0x40	; 64
      f8:	80 83       	st	Z, r24
		ADPS2:0: ADC Prescaler Select Bits
		These bits determine the division factor between the XTAL frequency and the input clock to the
		ADC. (See data sheet p.311 for table)
	*/
	// Setting the register to 11000111. Enables ADC and configures ADC prescaler to a 128 division factor. 
	ADCSRA |= (1 << ADEN) | (1 << ADPS2) | (1 << ADPS1) | (1 << ADPS0);
      fa:	ea e7       	ldi	r30, 0x7A	; 122
      fc:	f0 e0       	ldi	r31, 0x00	; 0
      fe:	80 81       	ld	r24, Z
     100:	87 68       	ori	r24, 0x87	; 135
     102:	80 83       	st	Z, r24
     104:	08 95       	ret

00000106 <adc_read>:
	uint8_t low;
	//_delay_ms(1000); // only reads every second. 
	/* ADSC bit in the ADCSRA register is toggled high to initiate an ADC read.
	   Since we have already selected F0 as our only ADC read pin the register
	   will read from that pin only. */ 
	ADCSRA |= (1<<ADSC); 
     106:	ea e7       	ldi	r30, 0x7A	; 122
     108:	f0 e0       	ldi	r31, 0x00	; 0
     10a:	80 81       	ld	r24, Z
     10c:	80 64       	ori	r24, 0x40	; 64
     10e:	80 83       	st	Z, r24
	
	/* Wait for a Valid Sample. 0x10 = 00010000 = ADATE  
	The ADATE bit in register ADCSRA is an auto trigger enable for the register. When conversion is complete it will go low.*/
	while ((ADCSRA & 0x10) == 0 );  
     110:	80 81       	ld	r24, Z
     112:	84 ff       	sbrs	r24, 4
     114:	fd cf       	rjmp	.-6      	; 0x110 <adc_read+0xa>
	
	/*After getting a valid read you have to toggle the interrupt flag ADIF in the ADCSRA register low again.
	  If we were using interrupts the flag would be reset automatically.  */
	ADCSRA |= (1<<ADIF); 
     116:	ea e7       	ldi	r30, 0x7A	; 122
     118:	f0 e0       	ldi	r31, 0x00	; 0
     11a:	80 81       	ld	r24, Z
     11c:	80 61       	ori	r24, 0x10	; 16
     11e:	80 83       	st	Z, r24
	
	/*We create the dummy variable low because if we set data= ((ADCH<<8) | ADCL); the register will read the lower bits first.
	for our reading we need it to see the ADCH bits first. By setting the low bits into an int we can get the compiler to set 
	all the bits in the correct order. */
	
	low = ADCL; // Must use to adjust bits in following equation. 
     120:	80 91 78 00 	lds	r24, 0x0078
	//ADC has two 8 bit registers to take in a reading, ADCH for the high bits and ADCL for the low bits.
	data = ((ADCH<<8) | low);
     124:	20 91 79 00 	lds	r18, 0x0079
     128:	90 e0       	ldi	r25, 0x00	; 0
	 
	return (data);
}
     12a:	92 2b       	or	r25, r18
     12c:	08 95       	ret

0000012e <convertTemp>:




// finds temp in range, then uses equation fitting for 1°C accuracy. If not in range returns 256.
double convertTemp(double resist){	
     12e:	cf 92       	push	r12
     130:	df 92       	push	r13
     132:	ef 92       	push	r14
     134:	ff 92       	push	r15
     136:	6b 01       	movw	r12, r22
     138:	7c 01       	movw	r14, r24
	

	// -55°C to -50°C range:
	if (resist <= 526240 && resist > 384520)
     13a:	20 e0       	ldi	r18, 0x00	; 0
     13c:	3a e7       	ldi	r19, 0x7A	; 122
     13e:	40 e0       	ldi	r20, 0x00	; 0
     140:	59 e4       	ldi	r21, 0x49	; 73
     142:	0e 94 2b 0c 	call	0x1856	; 0x1856 <__cmpsf2>
     146:	18 16       	cp	r1, r24
     148:	5c f0       	brlt	.+22     	; 0x160 <convertTemp+0x32>
     14a:	20 e0       	ldi	r18, 0x00	; 0
     14c:	31 ec       	ldi	r19, 0xC1	; 193
     14e:	4b eb       	ldi	r20, 0xBB	; 187
     150:	58 e4       	ldi	r21, 0x48	; 72
     152:	c7 01       	movw	r24, r14
     154:	b6 01       	movw	r22, r12
     156:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <__gesf2>
     15a:	18 16       	cp	r1, r24
     15c:	0c f4       	brge	.+2      	; 0x160 <convertTemp+0x32>
     15e:	15 c5       	rjmp	.+2602   	; 0xb8a <__stack+0x8b>
	{
		return -55;
	}
	
	// -50°C to -45°C range:
	else if (resist <= 384520 && resist > 284010)
     160:	20 e0       	ldi	r18, 0x00	; 0
     162:	31 ec       	ldi	r19, 0xC1	; 193
     164:	4b eb       	ldi	r20, 0xBB	; 187
     166:	58 e4       	ldi	r21, 0x48	; 72
     168:	c7 01       	movw	r24, r14
     16a:	b6 01       	movw	r22, r12
     16c:	0e 94 2b 0c 	call	0x1856	; 0x1856 <__cmpsf2>
     170:	18 16       	cp	r1, r24
     172:	5c f0       	brlt	.+22     	; 0x18a <convertTemp+0x5c>
     174:	20 e4       	ldi	r18, 0x40	; 64
     176:	3d ea       	ldi	r19, 0xAD	; 173
     178:	4a e8       	ldi	r20, 0x8A	; 138
     17a:	58 e4       	ldi	r21, 0x48	; 72
     17c:	c7 01       	movw	r24, r14
     17e:	b6 01       	movw	r22, r12
     180:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <__gesf2>
     184:	18 16       	cp	r1, r24
     186:	0c f4       	brge	.+2      	; 0x18a <convertTemp+0x5c>
     188:	05 c5       	rjmp	.+2570   	; 0xb94 <__stack+0x95>
	{
		return -50;
	}
	
	// -45°C to -40°C range:
	else if (resist <= 284010 && resist > 211940)
     18a:	20 e4       	ldi	r18, 0x40	; 64
     18c:	3d ea       	ldi	r19, 0xAD	; 173
     18e:	4a e8       	ldi	r20, 0x8A	; 138
     190:	58 e4       	ldi	r21, 0x48	; 72
     192:	c7 01       	movw	r24, r14
     194:	b6 01       	movw	r22, r12
     196:	0e 94 2b 0c 	call	0x1856	; 0x1856 <__cmpsf2>
     19a:	18 16       	cp	r1, r24
     19c:	5c f0       	brlt	.+22     	; 0x1b4 <convertTemp+0x86>
     19e:	20 e0       	ldi	r18, 0x00	; 0
     1a0:	39 ef       	ldi	r19, 0xF9	; 249
     1a2:	4e e4       	ldi	r20, 0x4E	; 78
     1a4:	58 e4       	ldi	r21, 0x48	; 72
     1a6:	c7 01       	movw	r24, r14
     1a8:	b6 01       	movw	r22, r12
     1aa:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <__gesf2>
     1ae:	18 16       	cp	r1, r24
     1b0:	0c f4       	brge	.+2      	; 0x1b4 <convertTemp+0x86>
     1b2:	f5 c4       	rjmp	.+2538   	; 0xb9e <__stack+0x9f>
	{
		return -45;
	}
	
	// -40°C to -35°C range:
	else if (resist <= 211940 && resist > 159720)
     1b4:	20 e0       	ldi	r18, 0x00	; 0
     1b6:	39 ef       	ldi	r19, 0xF9	; 249
     1b8:	4e e4       	ldi	r20, 0x4E	; 78
     1ba:	58 e4       	ldi	r21, 0x48	; 72
     1bc:	c7 01       	movw	r24, r14
     1be:	b6 01       	movw	r22, r12
     1c0:	0e 94 2b 0c 	call	0x1856	; 0x1856 <__cmpsf2>
     1c4:	18 16       	cp	r1, r24
     1c6:	5c f0       	brlt	.+22     	; 0x1de <convertTemp+0xb0>
     1c8:	20 e0       	ldi	r18, 0x00	; 0
     1ca:	3a ef       	ldi	r19, 0xFA	; 250
     1cc:	4b e1       	ldi	r20, 0x1B	; 27
     1ce:	58 e4       	ldi	r21, 0x48	; 72
     1d0:	c7 01       	movw	r24, r14
     1d2:	b6 01       	movw	r22, r12
     1d4:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <__gesf2>
     1d8:	18 16       	cp	r1, r24
     1da:	0c f4       	brge	.+2      	; 0x1de <convertTemp+0xb0>
     1dc:	e5 c4       	rjmp	.+2506   	; 0xba8 <__stack+0xa9>
	{
		return -40;
	}
	
	// -35°C to -30°C range:
	else if (resist <= 159720 && resist > 121490)
     1de:	20 e0       	ldi	r18, 0x00	; 0
     1e0:	3a ef       	ldi	r19, 0xFA	; 250
     1e2:	4b e1       	ldi	r20, 0x1B	; 27
     1e4:	58 e4       	ldi	r21, 0x48	; 72
     1e6:	c7 01       	movw	r24, r14
     1e8:	b6 01       	movw	r22, r12
     1ea:	0e 94 2b 0c 	call	0x1856	; 0x1856 <__cmpsf2>
     1ee:	18 16       	cp	r1, r24
     1f0:	5c f0       	brlt	.+22     	; 0x208 <convertTemp+0xda>
     1f2:	20 e0       	ldi	r18, 0x00	; 0
     1f4:	39 e4       	ldi	r19, 0x49	; 73
     1f6:	4d ee       	ldi	r20, 0xED	; 237
     1f8:	57 e4       	ldi	r21, 0x47	; 71
     1fa:	c7 01       	movw	r24, r14
     1fc:	b6 01       	movw	r22, r12
     1fe:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <__gesf2>
     202:	18 16       	cp	r1, r24
     204:	0c f4       	brge	.+2      	; 0x208 <convertTemp+0xda>
     206:	d5 c4       	rjmp	.+2474   	; 0xbb2 <__stack+0xb3>
	{
		return -35;
	}
	
	// -30°C to -25°C range:
	else if (resist <= 121490 && resist > 93246)
     208:	20 e0       	ldi	r18, 0x00	; 0
     20a:	39 e4       	ldi	r19, 0x49	; 73
     20c:	4d ee       	ldi	r20, 0xED	; 237
     20e:	57 e4       	ldi	r21, 0x47	; 71
     210:	c7 01       	movw	r24, r14
     212:	b6 01       	movw	r22, r12
     214:	0e 94 2b 0c 	call	0x1856	; 0x1856 <__cmpsf2>
     218:	18 16       	cp	r1, r24
     21a:	5c f0       	brlt	.+22     	; 0x232 <convertTemp+0x104>
     21c:	20 e0       	ldi	r18, 0x00	; 0
     21e:	3f e1       	ldi	r19, 0x1F	; 31
     220:	46 eb       	ldi	r20, 0xB6	; 182
     222:	57 e4       	ldi	r21, 0x47	; 71
     224:	c7 01       	movw	r24, r14
     226:	b6 01       	movw	r22, r12
     228:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <__gesf2>
     22c:	18 16       	cp	r1, r24
     22e:	0c f4       	brge	.+2      	; 0x232 <convertTemp+0x104>
     230:	c5 c4       	rjmp	.+2442   	; 0xbbc <__stack+0xbd>
	{
		return -30;
	}
	
	// -25°C to -20°C range:
	else if (resist <= 93246 && resist > 72181)
     232:	20 e0       	ldi	r18, 0x00	; 0
     234:	3f e1       	ldi	r19, 0x1F	; 31
     236:	46 eb       	ldi	r20, 0xB6	; 182
     238:	57 e4       	ldi	r21, 0x47	; 71
     23a:	c7 01       	movw	r24, r14
     23c:	b6 01       	movw	r22, r12
     23e:	0e 94 2b 0c 	call	0x1856	; 0x1856 <__cmpsf2>
     242:	18 16       	cp	r1, r24
     244:	5c f0       	brlt	.+22     	; 0x25c <convertTemp+0x12e>
     246:	20 e8       	ldi	r18, 0x80	; 128
     248:	3a ef       	ldi	r19, 0xFA	; 250
     24a:	4c e8       	ldi	r20, 0x8C	; 140
     24c:	57 e4       	ldi	r21, 0x47	; 71
     24e:	c7 01       	movw	r24, r14
     250:	b6 01       	movw	r22, r12
     252:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <__gesf2>
     256:	18 16       	cp	r1, r24
     258:	0c f4       	brge	.+2      	; 0x25c <convertTemp+0x12e>
     25a:	b5 c4       	rjmp	.+2410   	; 0xbc6 <__stack+0xc7>
	{
		return -25;
	}
	
	// -20°C to -15°C range:
	else if (resist <= 72181 && resist > 56332)
     25c:	20 e8       	ldi	r18, 0x80	; 128
     25e:	3a ef       	ldi	r19, 0xFA	; 250
     260:	4c e8       	ldi	r20, 0x8C	; 140
     262:	57 e4       	ldi	r21, 0x47	; 71
     264:	c7 01       	movw	r24, r14
     266:	b6 01       	movw	r22, r12
     268:	0e 94 2b 0c 	call	0x1856	; 0x1856 <__cmpsf2>
     26c:	18 16       	cp	r1, r24
     26e:	5c f0       	brlt	.+22     	; 0x286 <convertTemp+0x158>
     270:	20 e0       	ldi	r18, 0x00	; 0
     272:	3c e0       	ldi	r19, 0x0C	; 12
     274:	4c e5       	ldi	r20, 0x5C	; 92
     276:	57 e4       	ldi	r21, 0x47	; 71
     278:	c7 01       	movw	r24, r14
     27a:	b6 01       	movw	r22, r12
     27c:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <__gesf2>
     280:	18 16       	cp	r1, r24
     282:	0c f4       	brge	.+2      	; 0x286 <convertTemp+0x158>
     284:	a5 c4       	rjmp	.+2378   	; 0xbd0 <__stack+0xd1>
	{
		return -20;
	}
	
	// -15°C to -10°C range:
	else if (resist <= 56332 && resist > 44308)
     286:	20 e0       	ldi	r18, 0x00	; 0
     288:	3c e0       	ldi	r19, 0x0C	; 12
     28a:	4c e5       	ldi	r20, 0x5C	; 92
     28c:	57 e4       	ldi	r21, 0x47	; 71
     28e:	c7 01       	movw	r24, r14
     290:	b6 01       	movw	r22, r12
     292:	0e 94 2b 0c 	call	0x1856	; 0x1856 <__cmpsf2>
     296:	18 16       	cp	r1, r24
     298:	5c f0       	brlt	.+22     	; 0x2b0 <convertTemp+0x182>
     29a:	20 e0       	ldi	r18, 0x00	; 0
     29c:	34 e1       	ldi	r19, 0x14	; 20
     29e:	4d e2       	ldi	r20, 0x2D	; 45
     2a0:	57 e4       	ldi	r21, 0x47	; 71
     2a2:	c7 01       	movw	r24, r14
     2a4:	b6 01       	movw	r22, r12
     2a6:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <__gesf2>
     2aa:	18 16       	cp	r1, r24
     2ac:	0c f4       	brge	.+2      	; 0x2b0 <convertTemp+0x182>
     2ae:	95 c4       	rjmp	.+2346   	; 0xbda <__stack+0xdb>
	{
		return -15;
	}
	
	// -10°C to -5°C range:
	else if (resist <= 44308 && resist > 35112)
     2b0:	20 e0       	ldi	r18, 0x00	; 0
     2b2:	34 e1       	ldi	r19, 0x14	; 20
     2b4:	4d e2       	ldi	r20, 0x2D	; 45
     2b6:	57 e4       	ldi	r21, 0x47	; 71
     2b8:	c7 01       	movw	r24, r14
     2ba:	b6 01       	movw	r22, r12
     2bc:	0e 94 2b 0c 	call	0x1856	; 0x1856 <__cmpsf2>
     2c0:	18 16       	cp	r1, r24
     2c2:	5c f0       	brlt	.+22     	; 0x2da <convertTemp+0x1ac>
     2c4:	20 e0       	ldi	r18, 0x00	; 0
     2c6:	38 e2       	ldi	r19, 0x28	; 40
     2c8:	49 e0       	ldi	r20, 0x09	; 9
     2ca:	57 e4       	ldi	r21, 0x47	; 71
     2cc:	c7 01       	movw	r24, r14
     2ce:	b6 01       	movw	r22, r12
     2d0:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <__gesf2>
     2d4:	18 16       	cp	r1, r24
     2d6:	0c f4       	brge	.+2      	; 0x2da <convertTemp+0x1ac>
     2d8:	85 c4       	rjmp	.+2314   	; 0xbe4 <__stack+0xe5>
	{
		return -10;
	}
	
	// -5°C to 0°C range:
	else if (resist <= 35112 && resist > 28024)
     2da:	20 e0       	ldi	r18, 0x00	; 0
     2dc:	38 e2       	ldi	r19, 0x28	; 40
     2de:	49 e0       	ldi	r20, 0x09	; 9
     2e0:	57 e4       	ldi	r21, 0x47	; 71
     2e2:	c7 01       	movw	r24, r14
     2e4:	b6 01       	movw	r22, r12
     2e6:	0e 94 2b 0c 	call	0x1856	; 0x1856 <__cmpsf2>
     2ea:	18 16       	cp	r1, r24
     2ec:	5c f0       	brlt	.+22     	; 0x304 <convertTemp+0x1d6>
     2ee:	20 e0       	ldi	r18, 0x00	; 0
     2f0:	30 ef       	ldi	r19, 0xF0	; 240
     2f2:	4a ed       	ldi	r20, 0xDA	; 218
     2f4:	56 e4       	ldi	r21, 0x46	; 70
     2f6:	c7 01       	movw	r24, r14
     2f8:	b6 01       	movw	r22, r12
     2fa:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <__gesf2>
     2fe:	18 16       	cp	r1, r24
     300:	0c f4       	brge	.+2      	; 0x304 <convertTemp+0x1d6>
     302:	75 c4       	rjmp	.+2282   	; 0xbee <__stack+0xef>
	{
		return -5;
	}
	
	// 0°C to 5°C range:
	else if (resist <= 28024 && resist > 22520)
     304:	20 e0       	ldi	r18, 0x00	; 0
     306:	30 ef       	ldi	r19, 0xF0	; 240
     308:	4a ed       	ldi	r20, 0xDA	; 218
     30a:	56 e4       	ldi	r21, 0x46	; 70
     30c:	c7 01       	movw	r24, r14
     30e:	b6 01       	movw	r22, r12
     310:	0e 94 2b 0c 	call	0x1856	; 0x1856 <__cmpsf2>
     314:	18 16       	cp	r1, r24
     316:	5c f0       	brlt	.+22     	; 0x32e <convertTemp+0x200>
     318:	20 e0       	ldi	r18, 0x00	; 0
     31a:	30 ef       	ldi	r19, 0xF0	; 240
     31c:	4f ea       	ldi	r20, 0xAF	; 175
     31e:	56 e4       	ldi	r21, 0x46	; 70
     320:	c7 01       	movw	r24, r14
     322:	b6 01       	movw	r22, r12
     324:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <__gesf2>
     328:	18 16       	cp	r1, r24
     32a:	0c f4       	brge	.+2      	; 0x32e <convertTemp+0x200>
     32c:	65 c4       	rjmp	.+2250   	; 0xbf8 <__stack+0xf9>
	{
		return 0;
	}
	
	// 5°C to 10°C range:
	else if (resist <= 22520 && resist > 18216)
     32e:	20 e0       	ldi	r18, 0x00	; 0
     330:	30 ef       	ldi	r19, 0xF0	; 240
     332:	4f ea       	ldi	r20, 0xAF	; 175
     334:	56 e4       	ldi	r21, 0x46	; 70
     336:	c7 01       	movw	r24, r14
     338:	b6 01       	movw	r22, r12
     33a:	0e 94 2b 0c 	call	0x1856	; 0x1856 <__cmpsf2>
     33e:	18 16       	cp	r1, r24
     340:	5c f0       	brlt	.+22     	; 0x358 <convertTemp+0x22a>
     342:	20 e0       	ldi	r18, 0x00	; 0
     344:	30 e5       	ldi	r19, 0x50	; 80
     346:	4e e8       	ldi	r20, 0x8E	; 142
     348:	56 e4       	ldi	r21, 0x46	; 70
     34a:	c7 01       	movw	r24, r14
     34c:	b6 01       	movw	r22, r12
     34e:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <__gesf2>
     352:	18 16       	cp	r1, r24
     354:	0c f4       	brge	.+2      	; 0x358 <convertTemp+0x22a>
     356:	54 c4       	rjmp	.+2216   	; 0xc00 <__stack+0x101>
	{
		return 5;
	}
	
	// 10°C to 15°C range:
	else if (resist <= 18216 && resist > 14827)
     358:	20 e0       	ldi	r18, 0x00	; 0
     35a:	30 e5       	ldi	r19, 0x50	; 80
     35c:	4e e8       	ldi	r20, 0x8E	; 142
     35e:	56 e4       	ldi	r21, 0x46	; 70
     360:	c7 01       	movw	r24, r14
     362:	b6 01       	movw	r22, r12
     364:	0e 94 2b 0c 	call	0x1856	; 0x1856 <__cmpsf2>
     368:	18 16       	cp	r1, r24
     36a:	5c f0       	brlt	.+22     	; 0x382 <convertTemp+0x254>
     36c:	20 e0       	ldi	r18, 0x00	; 0
     36e:	3c ea       	ldi	r19, 0xAC	; 172
     370:	47 e6       	ldi	r20, 0x67	; 103
     372:	56 e4       	ldi	r21, 0x46	; 70
     374:	c7 01       	movw	r24, r14
     376:	b6 01       	movw	r22, r12
     378:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <__gesf2>
     37c:	18 16       	cp	r1, r24
     37e:	0c f4       	brge	.+2      	; 0x382 <convertTemp+0x254>
     380:	44 c4       	rjmp	.+2184   	; 0xc0a <__stack+0x10b>
	{
		return 10;
	}
	
	// 15°C to 20°C range:
	else if (resist <= 14827 && resist > 12142)
     382:	20 e0       	ldi	r18, 0x00	; 0
     384:	3c ea       	ldi	r19, 0xAC	; 172
     386:	47 e6       	ldi	r20, 0x67	; 103
     388:	56 e4       	ldi	r21, 0x46	; 70
     38a:	c7 01       	movw	r24, r14
     38c:	b6 01       	movw	r22, r12
     38e:	0e 94 2b 0c 	call	0x1856	; 0x1856 <__cmpsf2>
     392:	18 16       	cp	r1, r24
     394:	5c f0       	brlt	.+22     	; 0x3ac <convertTemp+0x27e>
     396:	20 e0       	ldi	r18, 0x00	; 0
     398:	38 eb       	ldi	r19, 0xB8	; 184
     39a:	4d e3       	ldi	r20, 0x3D	; 61
     39c:	56 e4       	ldi	r21, 0x46	; 70
     39e:	c7 01       	movw	r24, r14
     3a0:	b6 01       	movw	r22, r12
     3a2:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <__gesf2>
     3a6:	18 16       	cp	r1, r24
     3a8:	0c f4       	brge	.+2      	; 0x3ac <convertTemp+0x27e>
     3aa:	34 c4       	rjmp	.+2152   	; 0xc14 <__stack+0x115>
	/*******************************************************************************************************************
	********************* IN PCR RANGE *********************************************************************************
	*******************************************************************************************************************/
	
	// 20°C to 25°C range:
	else if (resist <= 12142 && resist > 10000)
     3ac:	20 e0       	ldi	r18, 0x00	; 0
     3ae:	38 eb       	ldi	r19, 0xB8	; 184
     3b0:	4d e3       	ldi	r20, 0x3D	; 61
     3b2:	56 e4       	ldi	r21, 0x46	; 70
     3b4:	c7 01       	movw	r24, r14
     3b6:	b6 01       	movw	r22, r12
     3b8:	0e 94 2b 0c 	call	0x1856	; 0x1856 <__cmpsf2>
     3bc:	18 16       	cp	r1, r24
     3be:	0c f4       	brge	.+2      	; 0x3c2 <convertTemp+0x294>
     3c0:	57 c0       	rjmp	.+174    	; 0x470 <convertTemp+0x342>
     3c2:	20 e0       	ldi	r18, 0x00	; 0
     3c4:	30 e4       	ldi	r19, 0x40	; 64
     3c6:	4c e1       	ldi	r20, 0x1C	; 28
     3c8:	56 e4       	ldi	r21, 0x46	; 70
     3ca:	c7 01       	movw	r24, r14
     3cc:	b6 01       	movw	r22, r12
     3ce:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <__gesf2>
     3d2:	18 16       	cp	r1, r24
     3d4:	0c f0       	brlt	.+2      	; 0x3d8 <convertTemp+0x2aa>
     3d6:	4c c0       	rjmp	.+152    	; 0x470 <convertTemp+0x342>
	{
		if (resist <= 12142 && resist > 11713.6)// 12142-10000 = 2142 & 2142/5 = 428.4
     3d8:	26 e6       	ldi	r18, 0x66	; 102
     3da:	36 e0       	ldi	r19, 0x06	; 6
     3dc:	47 e3       	ldi	r20, 0x37	; 55
     3de:	56 e4       	ldi	r21, 0x46	; 70
     3e0:	c7 01       	movw	r24, r14
     3e2:	b6 01       	movw	r22, r12
     3e4:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <__gesf2>
     3e8:	18 16       	cp	r1, r24
     3ea:	0c f4       	brge	.+2      	; 0x3ee <convertTemp+0x2c0>
     3ec:	18 c4       	rjmp	.+2096   	; 0xc1e <__stack+0x11f>
		{
		return 20;
		}
		else if (resist <= 11713.6 && resist > 11285.2)
     3ee:	26 e6       	ldi	r18, 0x66	; 102
     3f0:	36 e0       	ldi	r19, 0x06	; 6
     3f2:	47 e3       	ldi	r20, 0x37	; 55
     3f4:	56 e4       	ldi	r21, 0x46	; 70
     3f6:	c7 01       	movw	r24, r14
     3f8:	b6 01       	movw	r22, r12
     3fa:	0e 94 2b 0c 	call	0x1856	; 0x1856 <__cmpsf2>
     3fe:	18 16       	cp	r1, r24
     400:	5c f0       	brlt	.+22     	; 0x418 <convertTemp+0x2ea>
     402:	2d ec       	ldi	r18, 0xCD	; 205
     404:	34 e5       	ldi	r19, 0x54	; 84
     406:	40 e3       	ldi	r20, 0x30	; 48
     408:	56 e4       	ldi	r21, 0x46	; 70
     40a:	c7 01       	movw	r24, r14
     40c:	b6 01       	movw	r22, r12
     40e:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <__gesf2>
     412:	18 16       	cp	r1, r24
     414:	0c f4       	brge	.+2      	; 0x418 <convertTemp+0x2ea>
     416:	08 c4       	rjmp	.+2064   	; 0xc28 <__stack+0x129>
		{
			return 21;
		}
		else if (resist <= 11285.2 && resist > 10856.8)
     418:	2d ec       	ldi	r18, 0xCD	; 205
     41a:	34 e5       	ldi	r19, 0x54	; 84
     41c:	40 e3       	ldi	r20, 0x30	; 48
     41e:	56 e4       	ldi	r21, 0x46	; 70
     420:	c7 01       	movw	r24, r14
     422:	b6 01       	movw	r22, r12
     424:	0e 94 2b 0c 	call	0x1856	; 0x1856 <__cmpsf2>
     428:	18 16       	cp	r1, r24
     42a:	5c f0       	brlt	.+22     	; 0x442 <convertTemp+0x314>
     42c:	23 e3       	ldi	r18, 0x33	; 51
     42e:	33 ea       	ldi	r19, 0xA3	; 163
     430:	49 e2       	ldi	r20, 0x29	; 41
     432:	56 e4       	ldi	r21, 0x46	; 70
     434:	c7 01       	movw	r24, r14
     436:	b6 01       	movw	r22, r12
     438:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <__gesf2>
     43c:	18 16       	cp	r1, r24
     43e:	0c f4       	brge	.+2      	; 0x442 <convertTemp+0x314>
     440:	f8 c3       	rjmp	.+2032   	; 0xc32 <__stack+0x133>
		{
			return 22;
		}
		else if (resist <= 10856.8 && resist > 10428.4)
     442:	23 e3       	ldi	r18, 0x33	; 51
     444:	33 ea       	ldi	r19, 0xA3	; 163
     446:	49 e2       	ldi	r20, 0x29	; 41
     448:	56 e4       	ldi	r21, 0x46	; 70
     44a:	c7 01       	movw	r24, r14
     44c:	b6 01       	movw	r22, r12
     44e:	0e 94 2b 0c 	call	0x1856	; 0x1856 <__cmpsf2>
     452:	18 16       	cp	r1, r24
     454:	0c f4       	brge	.+2      	; 0x458 <convertTemp+0x32a>
     456:	51 c4       	rjmp	.+2210   	; 0xcfa <__stack+0x1fb>
     458:	2a e9       	ldi	r18, 0x9A	; 154
     45a:	31 ef       	ldi	r19, 0xF1	; 241
     45c:	42 e2       	ldi	r20, 0x22	; 34
     45e:	56 e4       	ldi	r21, 0x46	; 70
     460:	c7 01       	movw	r24, r14
     462:	b6 01       	movw	r22, r12
     464:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <__gesf2>
     468:	18 16       	cp	r1, r24
     46a:	0c f0       	brlt	.+2      	; 0x46e <convertTemp+0x340>
     46c:	46 c4       	rjmp	.+2188   	; 0xcfa <__stack+0x1fb>
     46e:	e6 c3       	rjmp	.+1996   	; 0xc3c <__stack+0x13d>
			return 24;
		}
	}
	
	// 25°C to 30°C range:
	else if (resist <= 10000 && resist > 8281.8)
     470:	20 e0       	ldi	r18, 0x00	; 0
     472:	30 e4       	ldi	r19, 0x40	; 64
     474:	4c e1       	ldi	r20, 0x1C	; 28
     476:	56 e4       	ldi	r21, 0x46	; 70
     478:	c7 01       	movw	r24, r14
     47a:	b6 01       	movw	r22, r12
     47c:	0e 94 2b 0c 	call	0x1856	; 0x1856 <__cmpsf2>
     480:	18 16       	cp	r1, r24
     482:	0c f4       	brge	.+2      	; 0x486 <convertTemp+0x358>
     484:	57 c0       	rjmp	.+174    	; 0x534 <convertTemp+0x406>
     486:	23 e3       	ldi	r18, 0x33	; 51
     488:	37 e6       	ldi	r19, 0x67	; 103
     48a:	41 e0       	ldi	r20, 0x01	; 1
     48c:	56 e4       	ldi	r21, 0x46	; 70
     48e:	c7 01       	movw	r24, r14
     490:	b6 01       	movw	r22, r12
     492:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <__gesf2>
     496:	18 16       	cp	r1, r24
     498:	0c f0       	brlt	.+2      	; 0x49c <convertTemp+0x36e>
     49a:	4c c0       	rjmp	.+152    	; 0x534 <convertTemp+0x406>
	{
		if (resist <= 10000 && resist > 9656.36) // 10000-8281.8 = 1718.2 & 1718.2/5 = 343.64
     49c:	21 e7       	ldi	r18, 0x71	; 113
     49e:	31 ee       	ldi	r19, 0xE1	; 225
     4a0:	46 e1       	ldi	r20, 0x16	; 22
     4a2:	56 e4       	ldi	r21, 0x46	; 70
     4a4:	c7 01       	movw	r24, r14
     4a6:	b6 01       	movw	r22, r12
     4a8:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <__gesf2>
     4ac:	18 16       	cp	r1, r24
     4ae:	0c f4       	brge	.+2      	; 0x4b2 <convertTemp+0x384>
     4b0:	ca c3       	rjmp	.+1940   	; 0xc46 <__stack+0x147>
		{
		return 25;
		}
		else if (resist <= 9656.36 && resist > 9312.72)
     4b2:	21 e7       	ldi	r18, 0x71	; 113
     4b4:	31 ee       	ldi	r19, 0xE1	; 225
     4b6:	46 e1       	ldi	r20, 0x16	; 22
     4b8:	56 e4       	ldi	r21, 0x46	; 70
     4ba:	c7 01       	movw	r24, r14
     4bc:	b6 01       	movw	r22, r12
     4be:	0e 94 2b 0c 	call	0x1856	; 0x1856 <__cmpsf2>
     4c2:	18 16       	cp	r1, r24
     4c4:	5c f0       	brlt	.+22     	; 0x4dc <convertTemp+0x3ae>
     4c6:	21 ee       	ldi	r18, 0xE1	; 225
     4c8:	32 e8       	ldi	r19, 0x82	; 130
     4ca:	41 e1       	ldi	r20, 0x11	; 17
     4cc:	56 e4       	ldi	r21, 0x46	; 70
     4ce:	c7 01       	movw	r24, r14
     4d0:	b6 01       	movw	r22, r12
     4d2:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <__gesf2>
     4d6:	18 16       	cp	r1, r24
     4d8:	0c f4       	brge	.+2      	; 0x4dc <convertTemp+0x3ae>
     4da:	ba c3       	rjmp	.+1908   	; 0xc50 <__stack+0x151>
		{
			return 26;
		}
		else if (resist <= 9312.72 && resist > 8969.08)
     4dc:	21 ee       	ldi	r18, 0xE1	; 225
     4de:	32 e8       	ldi	r19, 0x82	; 130
     4e0:	41 e1       	ldi	r20, 0x11	; 17
     4e2:	56 e4       	ldi	r21, 0x46	; 70
     4e4:	c7 01       	movw	r24, r14
     4e6:	b6 01       	movw	r22, r12
     4e8:	0e 94 2b 0c 	call	0x1856	; 0x1856 <__cmpsf2>
     4ec:	18 16       	cp	r1, r24
     4ee:	5c f0       	brlt	.+22     	; 0x506 <convertTemp+0x3d8>
     4f0:	22 e5       	ldi	r18, 0x52	; 82
     4f2:	34 e2       	ldi	r19, 0x24	; 36
     4f4:	4c e0       	ldi	r20, 0x0C	; 12
     4f6:	56 e4       	ldi	r21, 0x46	; 70
     4f8:	c7 01       	movw	r24, r14
     4fa:	b6 01       	movw	r22, r12
     4fc:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <__gesf2>
     500:	18 16       	cp	r1, r24
     502:	0c f4       	brge	.+2      	; 0x506 <convertTemp+0x3d8>
     504:	aa c3       	rjmp	.+1876   	; 0xc5a <__stack+0x15b>
		{
			return 27;
		}
		else if (resist <= 8969.08 && resist > 8625.44)
     506:	22 e5       	ldi	r18, 0x52	; 82
     508:	34 e2       	ldi	r19, 0x24	; 36
     50a:	4c e0       	ldi	r20, 0x0C	; 12
     50c:	56 e4       	ldi	r21, 0x46	; 70
     50e:	c7 01       	movw	r24, r14
     510:	b6 01       	movw	r22, r12
     512:	0e 94 2b 0c 	call	0x1856	; 0x1856 <__cmpsf2>
     516:	18 16       	cp	r1, r24
     518:	0c f4       	brge	.+2      	; 0x51c <convertTemp+0x3ee>
     51a:	fe c3       	rjmp	.+2044   	; 0xd18 <__stack+0x219>
     51c:	23 ec       	ldi	r18, 0xC3	; 195
     51e:	35 ec       	ldi	r19, 0xC5	; 197
     520:	46 e0       	ldi	r20, 0x06	; 6
     522:	56 e4       	ldi	r21, 0x46	; 70
     524:	c7 01       	movw	r24, r14
     526:	b6 01       	movw	r22, r12
     528:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <__gesf2>
     52c:	18 16       	cp	r1, r24
     52e:	0c f0       	brlt	.+2      	; 0x532 <convertTemp+0x404>
     530:	f3 c3       	rjmp	.+2022   	; 0xd18 <__stack+0x219>
     532:	98 c3       	rjmp	.+1840   	; 0xc64 <__stack+0x165>
			return 29;
		}
	}
	
	// 30°C to 35°C range:
	else if (resist <= 8281.8 && resist > 6895.4)
     534:	23 e3       	ldi	r18, 0x33	; 51
     536:	37 e6       	ldi	r19, 0x67	; 103
     538:	41 e0       	ldi	r20, 0x01	; 1
     53a:	56 e4       	ldi	r21, 0x46	; 70
     53c:	c7 01       	movw	r24, r14
     53e:	b6 01       	movw	r22, r12
     540:	0e 94 2b 0c 	call	0x1856	; 0x1856 <__cmpsf2>
     544:	18 16       	cp	r1, r24
     546:	fc f0       	brlt	.+62     	; 0x586 <convertTemp+0x458>
     548:	23 e3       	ldi	r18, 0x33	; 51
     54a:	3b e7       	ldi	r19, 0x7B	; 123
     54c:	47 ed       	ldi	r20, 0xD7	; 215
     54e:	55 e4       	ldi	r21, 0x45	; 69
     550:	c7 01       	movw	r24, r14
     552:	b6 01       	movw	r22, r12
     554:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <__gesf2>
     558:	18 16       	cp	r1, r24
     55a:	ac f4       	brge	.+42     	; 0x586 <convertTemp+0x458>
	{
		return 30 + (8281.8 - resist)/277.28;
     55c:	a7 01       	movw	r20, r14
     55e:	96 01       	movw	r18, r12
     560:	63 e3       	ldi	r22, 0x33	; 51
     562:	77 e6       	ldi	r23, 0x67	; 103
     564:	81 e0       	ldi	r24, 0x01	; 1
     566:	96 e4       	ldi	r25, 0x46	; 70
     568:	0e 94 be 0b 	call	0x177c	; 0x177c <__subsf3>
     56c:	27 ed       	ldi	r18, 0xD7	; 215
     56e:	33 ea       	ldi	r19, 0xA3	; 163
     570:	4a e8       	ldi	r20, 0x8A	; 138
     572:	53 e4       	ldi	r21, 0x43	; 67
     574:	0e 94 30 0c 	call	0x1860	; 0x1860 <__divsf3>
     578:	20 e0       	ldi	r18, 0x00	; 0
     57a:	30 e0       	ldi	r19, 0x00	; 0
     57c:	40 ef       	ldi	r20, 0xF0	; 240
     57e:	51 e4       	ldi	r21, 0x41	; 65
     580:	0e 94 bf 0b 	call	0x177e	; 0x177e <__addsf3>
     584:	d7 c3       	rjmp	.+1966   	; 0xd34 <__stack+0x235>
		}
		*/
	}
	
	// 35°C to 40°C range:
	else if (resist <= 6895.4 && resist > 5770.3)
     586:	23 e3       	ldi	r18, 0x33	; 51
     588:	3b e7       	ldi	r19, 0x7B	; 123
     58a:	47 ed       	ldi	r20, 0xD7	; 215
     58c:	55 e4       	ldi	r21, 0x45	; 69
     58e:	c7 01       	movw	r24, r14
     590:	b6 01       	movw	r22, r12
     592:	0e 94 2b 0c 	call	0x1856	; 0x1856 <__cmpsf2>
     596:	18 16       	cp	r1, r24
     598:	fc f0       	brlt	.+62     	; 0x5d8 <convertTemp+0x4aa>
     59a:	26 e6       	ldi	r18, 0x66	; 102
     59c:	32 e5       	ldi	r19, 0x52	; 82
     59e:	44 eb       	ldi	r20, 0xB4	; 180
     5a0:	55 e4       	ldi	r21, 0x45	; 69
     5a2:	c7 01       	movw	r24, r14
     5a4:	b6 01       	movw	r22, r12
     5a6:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <__gesf2>
     5aa:	18 16       	cp	r1, r24
     5ac:	ac f4       	brge	.+42     	; 0x5d8 <convertTemp+0x4aa>
	{
		return 35 + (6895.4 - resist)/225.02;
     5ae:	a7 01       	movw	r20, r14
     5b0:	96 01       	movw	r18, r12
     5b2:	63 e3       	ldi	r22, 0x33	; 51
     5b4:	7b e7       	ldi	r23, 0x7B	; 123
     5b6:	87 ed       	ldi	r24, 0xD7	; 215
     5b8:	95 e4       	ldi	r25, 0x45	; 69
     5ba:	0e 94 be 0b 	call	0x177c	; 0x177c <__subsf3>
     5be:	2f e1       	ldi	r18, 0x1F	; 31
     5c0:	35 e0       	ldi	r19, 0x05	; 5
     5c2:	41 e6       	ldi	r20, 0x61	; 97
     5c4:	53 e4       	ldi	r21, 0x43	; 67
     5c6:	0e 94 30 0c 	call	0x1860	; 0x1860 <__divsf3>
     5ca:	20 e0       	ldi	r18, 0x00	; 0
     5cc:	30 e0       	ldi	r19, 0x00	; 0
     5ce:	4c e0       	ldi	r20, 0x0C	; 12
     5d0:	52 e4       	ldi	r21, 0x42	; 66
     5d2:	0e 94 bf 0b 	call	0x177e	; 0x177e <__addsf3>
     5d6:	ae c3       	rjmp	.+1884   	; 0xd34 <__stack+0x235>
		}
		*/
	}
	
	// 40°C to 45°C range:
	else if (resist <= 5770.3 && resist > 4852.5)
     5d8:	26 e6       	ldi	r18, 0x66	; 102
     5da:	32 e5       	ldi	r19, 0x52	; 82
     5dc:	44 eb       	ldi	r20, 0xB4	; 180
     5de:	55 e4       	ldi	r21, 0x45	; 69
     5e0:	c7 01       	movw	r24, r14
     5e2:	b6 01       	movw	r22, r12
     5e4:	0e 94 2b 0c 	call	0x1856	; 0x1856 <__cmpsf2>
     5e8:	18 16       	cp	r1, r24
     5ea:	fc f0       	brlt	.+62     	; 0x62a <convertTemp+0x4fc>
     5ec:	20 e0       	ldi	r18, 0x00	; 0
     5ee:	34 ea       	ldi	r19, 0xA4	; 164
     5f0:	47 e9       	ldi	r20, 0x97	; 151
     5f2:	55 e4       	ldi	r21, 0x45	; 69
     5f4:	c7 01       	movw	r24, r14
     5f6:	b6 01       	movw	r22, r12
     5f8:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <__gesf2>
     5fc:	18 16       	cp	r1, r24
     5fe:	ac f4       	brge	.+42     	; 0x62a <convertTemp+0x4fc>
	{
		return 40 + (5770.3 - resist)/183.56;
     600:	a7 01       	movw	r20, r14
     602:	96 01       	movw	r18, r12
     604:	66 e6       	ldi	r22, 0x66	; 102
     606:	72 e5       	ldi	r23, 0x52	; 82
     608:	84 eb       	ldi	r24, 0xB4	; 180
     60a:	95 e4       	ldi	r25, 0x45	; 69
     60c:	0e 94 be 0b 	call	0x177c	; 0x177c <__subsf3>
     610:	2c e5       	ldi	r18, 0x5C	; 92
     612:	3f e8       	ldi	r19, 0x8F	; 143
     614:	47 e3       	ldi	r20, 0x37	; 55
     616:	53 e4       	ldi	r21, 0x43	; 67
     618:	0e 94 30 0c 	call	0x1860	; 0x1860 <__divsf3>
     61c:	20 e0       	ldi	r18, 0x00	; 0
     61e:	30 e0       	ldi	r19, 0x00	; 0
     620:	40 e2       	ldi	r20, 0x20	; 32
     622:	52 e4       	ldi	r21, 0x42	; 66
     624:	0e 94 bf 0b 	call	0x177e	; 0x177e <__addsf3>
     628:	85 c3       	rjmp	.+1802   	; 0xd34 <__stack+0x235>
		}
		*/
	}
	
	// 45°C to 50°C range:
	else if (resist <= 4852.5 && resist > 4100)
     62a:	20 e0       	ldi	r18, 0x00	; 0
     62c:	34 ea       	ldi	r19, 0xA4	; 164
     62e:	47 e9       	ldi	r20, 0x97	; 151
     630:	55 e4       	ldi	r21, 0x45	; 69
     632:	c7 01       	movw	r24, r14
     634:	b6 01       	movw	r22, r12
     636:	0e 94 2b 0c 	call	0x1856	; 0x1856 <__cmpsf2>
     63a:	18 16       	cp	r1, r24
     63c:	fc f0       	brlt	.+62     	; 0x67c <convertTemp+0x54e>
     63e:	20 e0       	ldi	r18, 0x00	; 0
     640:	30 e2       	ldi	r19, 0x20	; 32
     642:	40 e8       	ldi	r20, 0x80	; 128
     644:	55 e4       	ldi	r21, 0x45	; 69
     646:	c7 01       	movw	r24, r14
     648:	b6 01       	movw	r22, r12
     64a:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <__gesf2>
     64e:	18 16       	cp	r1, r24
     650:	ac f4       	brge	.+42     	; 0x67c <convertTemp+0x54e>
	{
		return 45 + (4852.5 - resist)/150.5;
     652:	a7 01       	movw	r20, r14
     654:	96 01       	movw	r18, r12
     656:	60 e0       	ldi	r22, 0x00	; 0
     658:	74 ea       	ldi	r23, 0xA4	; 164
     65a:	87 e9       	ldi	r24, 0x97	; 151
     65c:	95 e4       	ldi	r25, 0x45	; 69
     65e:	0e 94 be 0b 	call	0x177c	; 0x177c <__subsf3>
     662:	20 e0       	ldi	r18, 0x00	; 0
     664:	30 e8       	ldi	r19, 0x80	; 128
     666:	46 e1       	ldi	r20, 0x16	; 22
     668:	53 e4       	ldi	r21, 0x43	; 67
     66a:	0e 94 30 0c 	call	0x1860	; 0x1860 <__divsf3>
     66e:	20 e0       	ldi	r18, 0x00	; 0
     670:	30 e0       	ldi	r19, 0x00	; 0
     672:	44 e3       	ldi	r20, 0x34	; 52
     674:	52 e4       	ldi	r21, 0x42	; 66
     676:	0e 94 bf 0b 	call	0x177e	; 0x177e <__addsf3>
     67a:	5c c3       	rjmp	.+1720   	; 0xd34 <__stack+0x235>
		}
		*/
	}
	
	// 50°C to 55°C range:
	else if (resist <= 4100 && resist > 3479.8)
     67c:	20 e0       	ldi	r18, 0x00	; 0
     67e:	30 e2       	ldi	r19, 0x20	; 32
     680:	40 e8       	ldi	r20, 0x80	; 128
     682:	55 e4       	ldi	r21, 0x45	; 69
     684:	c7 01       	movw	r24, r14
     686:	b6 01       	movw	r22, r12
     688:	0e 94 2b 0c 	call	0x1856	; 0x1856 <__cmpsf2>
     68c:	18 16       	cp	r1, r24
     68e:	fc f0       	brlt	.+62     	; 0x6ce <convertTemp+0x5a0>
     690:	2d ec       	ldi	r18, 0xCD	; 205
     692:	3c e7       	ldi	r19, 0x7C	; 124
     694:	49 e5       	ldi	r20, 0x59	; 89
     696:	55 e4       	ldi	r21, 0x45	; 69
     698:	c7 01       	movw	r24, r14
     69a:	b6 01       	movw	r22, r12
     69c:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <__gesf2>
     6a0:	18 16       	cp	r1, r24
     6a2:	ac f4       	brge	.+42     	; 0x6ce <convertTemp+0x5a0>
	{
		return 50 + (4100 - resist)/124.04;
     6a4:	a7 01       	movw	r20, r14
     6a6:	96 01       	movw	r18, r12
     6a8:	60 e0       	ldi	r22, 0x00	; 0
     6aa:	70 e2       	ldi	r23, 0x20	; 32
     6ac:	80 e8       	ldi	r24, 0x80	; 128
     6ae:	95 e4       	ldi	r25, 0x45	; 69
     6b0:	0e 94 be 0b 	call	0x177c	; 0x177c <__subsf3>
     6b4:	2b e7       	ldi	r18, 0x7B	; 123
     6b6:	34 e1       	ldi	r19, 0x14	; 20
     6b8:	48 ef       	ldi	r20, 0xF8	; 248
     6ba:	52 e4       	ldi	r21, 0x42	; 66
     6bc:	0e 94 30 0c 	call	0x1860	; 0x1860 <__divsf3>
     6c0:	20 e0       	ldi	r18, 0x00	; 0
     6c2:	30 e0       	ldi	r19, 0x00	; 0
     6c4:	48 e4       	ldi	r20, 0x48	; 72
     6c6:	52 e4       	ldi	r21, 0x42	; 66
     6c8:	0e 94 bf 0b 	call	0x177e	; 0x177e <__addsf3>
     6cc:	33 c3       	rjmp	.+1638   	; 0xd34 <__stack+0x235>
		}
		*/
	}
	
	// 55°C to 60°C range:
	else if (resist <= 3479.8 && resist > 2966.3)
     6ce:	2d ec       	ldi	r18, 0xCD	; 205
     6d0:	3c e7       	ldi	r19, 0x7C	; 124
     6d2:	49 e5       	ldi	r20, 0x59	; 89
     6d4:	55 e4       	ldi	r21, 0x45	; 69
     6d6:	c7 01       	movw	r24, r14
     6d8:	b6 01       	movw	r22, r12
     6da:	0e 94 2b 0c 	call	0x1856	; 0x1856 <__cmpsf2>
     6de:	18 16       	cp	r1, r24
     6e0:	fc f0       	brlt	.+62     	; 0x720 <convertTemp+0x5f2>
     6e2:	2d ec       	ldi	r18, 0xCD	; 205
     6e4:	34 e6       	ldi	r19, 0x64	; 100
     6e6:	49 e3       	ldi	r20, 0x39	; 57
     6e8:	55 e4       	ldi	r21, 0x45	; 69
     6ea:	c7 01       	movw	r24, r14
     6ec:	b6 01       	movw	r22, r12
     6ee:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <__gesf2>
     6f2:	18 16       	cp	r1, r24
     6f4:	ac f4       	brge	.+42     	; 0x720 <convertTemp+0x5f2>
	{
		return 55 + (3479.8 - resist)/102.7;
     6f6:	a7 01       	movw	r20, r14
     6f8:	96 01       	movw	r18, r12
     6fa:	6d ec       	ldi	r22, 0xCD	; 205
     6fc:	7c e7       	ldi	r23, 0x7C	; 124
     6fe:	89 e5       	ldi	r24, 0x59	; 89
     700:	95 e4       	ldi	r25, 0x45	; 69
     702:	0e 94 be 0b 	call	0x177c	; 0x177c <__subsf3>
     706:	26 e6       	ldi	r18, 0x66	; 102
     708:	36 e6       	ldi	r19, 0x66	; 102
     70a:	4d ec       	ldi	r20, 0xCD	; 205
     70c:	52 e4       	ldi	r21, 0x42	; 66
     70e:	0e 94 30 0c 	call	0x1860	; 0x1860 <__divsf3>
     712:	20 e0       	ldi	r18, 0x00	; 0
     714:	30 e0       	ldi	r19, 0x00	; 0
     716:	4c e5       	ldi	r20, 0x5C	; 92
     718:	52 e4       	ldi	r21, 0x42	; 66
     71a:	0e 94 bf 0b 	call	0x177e	; 0x177e <__addsf3>
     71e:	0a c3       	rjmp	.+1556   	; 0xd34 <__stack+0x235>
		}
		*/
	}
	
	// 60°C to 65°C range:
	else if ((resist <= 2966.3) && (resist > 2539.2))
     720:	2d ec       	ldi	r18, 0xCD	; 205
     722:	34 e6       	ldi	r19, 0x64	; 100
     724:	49 e3       	ldi	r20, 0x39	; 57
     726:	55 e4       	ldi	r21, 0x45	; 69
     728:	c7 01       	movw	r24, r14
     72a:	b6 01       	movw	r22, r12
     72c:	0e 94 2b 0c 	call	0x1856	; 0x1856 <__cmpsf2>
     730:	18 16       	cp	r1, r24
     732:	fc f0       	brlt	.+62     	; 0x772 <convertTemp+0x644>
     734:	23 e3       	ldi	r18, 0x33	; 51
     736:	33 eb       	ldi	r19, 0xB3	; 179
     738:	4e e1       	ldi	r20, 0x1E	; 30
     73a:	55 e4       	ldi	r21, 0x45	; 69
     73c:	c7 01       	movw	r24, r14
     73e:	b6 01       	movw	r22, r12
     740:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <__gesf2>
     744:	18 16       	cp	r1, r24
     746:	ac f4       	brge	.+42     	; 0x772 <convertTemp+0x644>
	{
		return 60 + (2966.3 - resist)/85.42;
     748:	a7 01       	movw	r20, r14
     74a:	96 01       	movw	r18, r12
     74c:	6d ec       	ldi	r22, 0xCD	; 205
     74e:	74 e6       	ldi	r23, 0x64	; 100
     750:	89 e3       	ldi	r24, 0x39	; 57
     752:	95 e4       	ldi	r25, 0x45	; 69
     754:	0e 94 be 0b 	call	0x177c	; 0x177c <__subsf3>
     758:	2a e0       	ldi	r18, 0x0A	; 10
     75a:	37 ed       	ldi	r19, 0xD7	; 215
     75c:	4a ea       	ldi	r20, 0xAA	; 170
     75e:	52 e4       	ldi	r21, 0x42	; 66
     760:	0e 94 30 0c 	call	0x1860	; 0x1860 <__divsf3>
     764:	20 e0       	ldi	r18, 0x00	; 0
     766:	30 e0       	ldi	r19, 0x00	; 0
     768:	40 e7       	ldi	r20, 0x70	; 112
     76a:	52 e4       	ldi	r21, 0x42	; 66
     76c:	0e 94 bf 0b 	call	0x177e	; 0x177e <__addsf3>
     770:	e1 c2       	rjmp	.+1474   	; 0xd34 <__stack+0x235>
		}
		*/
	}
	
	// 65°C to 70°C range:
	else if (resist <= 2539.2 && resist > 2182.4)
     772:	23 e3       	ldi	r18, 0x33	; 51
     774:	33 eb       	ldi	r19, 0xB3	; 179
     776:	4e e1       	ldi	r20, 0x1E	; 30
     778:	55 e4       	ldi	r21, 0x45	; 69
     77a:	c7 01       	movw	r24, r14
     77c:	b6 01       	movw	r22, r12
     77e:	0e 94 2b 0c 	call	0x1856	; 0x1856 <__cmpsf2>
     782:	18 16       	cp	r1, r24
     784:	fc f0       	brlt	.+62     	; 0x7c4 <convertTemp+0x696>
     786:	26 e6       	ldi	r18, 0x66	; 102
     788:	36 e6       	ldi	r19, 0x66	; 102
     78a:	48 e0       	ldi	r20, 0x08	; 8
     78c:	55 e4       	ldi	r21, 0x45	; 69
     78e:	c7 01       	movw	r24, r14
     790:	b6 01       	movw	r22, r12
     792:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <__gesf2>
     796:	18 16       	cp	r1, r24
     798:	ac f4       	brge	.+42     	; 0x7c4 <convertTemp+0x696>
	{
		return 65 + (2539.2 - resist)/71.36;
     79a:	a7 01       	movw	r20, r14
     79c:	96 01       	movw	r18, r12
     79e:	63 e3       	ldi	r22, 0x33	; 51
     7a0:	73 eb       	ldi	r23, 0xB3	; 179
     7a2:	8e e1       	ldi	r24, 0x1E	; 30
     7a4:	95 e4       	ldi	r25, 0x45	; 69
     7a6:	0e 94 be 0b 	call	0x177c	; 0x177c <__subsf3>
     7aa:	22 e5       	ldi	r18, 0x52	; 82
     7ac:	38 eb       	ldi	r19, 0xB8	; 184
     7ae:	4e e8       	ldi	r20, 0x8E	; 142
     7b0:	52 e4       	ldi	r21, 0x42	; 66
     7b2:	0e 94 30 0c 	call	0x1860	; 0x1860 <__divsf3>
     7b6:	20 e0       	ldi	r18, 0x00	; 0
     7b8:	30 e0       	ldi	r19, 0x00	; 0
     7ba:	42 e8       	ldi	r20, 0x82	; 130
     7bc:	52 e4       	ldi	r21, 0x42	; 66
     7be:	0e 94 bf 0b 	call	0x177e	; 0x177e <__addsf3>
     7c2:	b8 c2       	rjmp	.+1392   	; 0xd34 <__stack+0x235>
		}
		*/
	}
	
	// 70°C to 75°C range:
	else if (resist <= 2182.4 && resist > 1883)
     7c4:	26 e6       	ldi	r18, 0x66	; 102
     7c6:	36 e6       	ldi	r19, 0x66	; 102
     7c8:	48 e0       	ldi	r20, 0x08	; 8
     7ca:	55 e4       	ldi	r21, 0x45	; 69
     7cc:	c7 01       	movw	r24, r14
     7ce:	b6 01       	movw	r22, r12
     7d0:	0e 94 2b 0c 	call	0x1856	; 0x1856 <__cmpsf2>
     7d4:	18 16       	cp	r1, r24
     7d6:	fc f0       	brlt	.+62     	; 0x816 <convertTemp+0x6e8>
     7d8:	20 e0       	ldi	r18, 0x00	; 0
     7da:	30 e6       	ldi	r19, 0x60	; 96
     7dc:	4b ee       	ldi	r20, 0xEB	; 235
     7de:	54 e4       	ldi	r21, 0x44	; 68
     7e0:	c7 01       	movw	r24, r14
     7e2:	b6 01       	movw	r22, r12
     7e4:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <__gesf2>
     7e8:	18 16       	cp	r1, r24
     7ea:	ac f4       	brge	.+42     	; 0x816 <convertTemp+0x6e8>
	{
		return 70 + (2182.4 - resist)/59.88;
     7ec:	a7 01       	movw	r20, r14
     7ee:	96 01       	movw	r18, r12
     7f0:	66 e6       	ldi	r22, 0x66	; 102
     7f2:	76 e6       	ldi	r23, 0x66	; 102
     7f4:	88 e0       	ldi	r24, 0x08	; 8
     7f6:	95 e4       	ldi	r25, 0x45	; 69
     7f8:	0e 94 be 0b 	call	0x177c	; 0x177c <__subsf3>
     7fc:	2f e1       	ldi	r18, 0x1F	; 31
     7fe:	35 e8       	ldi	r19, 0x85	; 133
     800:	4f e6       	ldi	r20, 0x6F	; 111
     802:	52 e4       	ldi	r21, 0x42	; 66
     804:	0e 94 30 0c 	call	0x1860	; 0x1860 <__divsf3>
     808:	20 e0       	ldi	r18, 0x00	; 0
     80a:	30 e0       	ldi	r19, 0x00	; 0
     80c:	4c e8       	ldi	r20, 0x8C	; 140
     80e:	52 e4       	ldi	r21, 0x42	; 66
     810:	0e 94 bf 0b 	call	0x177e	; 0x177e <__addsf3>
     814:	8f c2       	rjmp	.+1310   	; 0xd34 <__stack+0x235>
		}
		*/
	}
	
	// 75°C to 80°C range:
	else if (resist <= 1883 && resist > 1630.7)
     816:	20 e0       	ldi	r18, 0x00	; 0
     818:	30 e6       	ldi	r19, 0x60	; 96
     81a:	4b ee       	ldi	r20, 0xEB	; 235
     81c:	54 e4       	ldi	r21, 0x44	; 68
     81e:	c7 01       	movw	r24, r14
     820:	b6 01       	movw	r22, r12
     822:	0e 94 2b 0c 	call	0x1856	; 0x1856 <__cmpsf2>
     826:	18 16       	cp	r1, r24
     828:	fc f0       	brlt	.+62     	; 0x868 <convertTemp+0x73a>
     82a:	26 e6       	ldi	r18, 0x66	; 102
     82c:	36 ed       	ldi	r19, 0xD6	; 214
     82e:	4b ec       	ldi	r20, 0xCB	; 203
     830:	54 e4       	ldi	r21, 0x44	; 68
     832:	c7 01       	movw	r24, r14
     834:	b6 01       	movw	r22, r12
     836:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <__gesf2>
     83a:	18 16       	cp	r1, r24
     83c:	ac f4       	brge	.+42     	; 0x868 <convertTemp+0x73a>
	{
		return 75 + (1883 - resist)/50.46;
     83e:	a7 01       	movw	r20, r14
     840:	96 01       	movw	r18, r12
     842:	60 e0       	ldi	r22, 0x00	; 0
     844:	70 e6       	ldi	r23, 0x60	; 96
     846:	8b ee       	ldi	r24, 0xEB	; 235
     848:	94 e4       	ldi	r25, 0x44	; 68
     84a:	0e 94 be 0b 	call	0x177c	; 0x177c <__subsf3>
     84e:	2a e0       	ldi	r18, 0x0A	; 10
     850:	37 ed       	ldi	r19, 0xD7	; 215
     852:	49 e4       	ldi	r20, 0x49	; 73
     854:	52 e4       	ldi	r21, 0x42	; 66
     856:	0e 94 30 0c 	call	0x1860	; 0x1860 <__divsf3>
     85a:	20 e0       	ldi	r18, 0x00	; 0
     85c:	30 e0       	ldi	r19, 0x00	; 0
     85e:	46 e9       	ldi	r20, 0x96	; 150
     860:	52 e4       	ldi	r21, 0x42	; 66
     862:	0e 94 bf 0b 	call	0x177e	; 0x177e <__addsf3>
     866:	66 c2       	rjmp	.+1228   	; 0xd34 <__stack+0x235>
		}
		*/
	}
	
	// 80°C to 85°C range:
	else if (resist <= 1630.7 && resist > 1417.4)
     868:	26 e6       	ldi	r18, 0x66	; 102
     86a:	36 ed       	ldi	r19, 0xD6	; 214
     86c:	4b ec       	ldi	r20, 0xCB	; 203
     86e:	54 e4       	ldi	r21, 0x44	; 68
     870:	c7 01       	movw	r24, r14
     872:	b6 01       	movw	r22, r12
     874:	0e 94 2b 0c 	call	0x1856	; 0x1856 <__cmpsf2>
     878:	18 16       	cp	r1, r24
     87a:	fc f0       	brlt	.+62     	; 0x8ba <convertTemp+0x78c>
     87c:	2d ec       	ldi	r18, 0xCD	; 205
     87e:	3c e2       	ldi	r19, 0x2C	; 44
     880:	41 eb       	ldi	r20, 0xB1	; 177
     882:	54 e4       	ldi	r21, 0x44	; 68
     884:	c7 01       	movw	r24, r14
     886:	b6 01       	movw	r22, r12
     888:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <__gesf2>
     88c:	18 16       	cp	r1, r24
     88e:	ac f4       	brge	.+42     	; 0x8ba <convertTemp+0x78c>
	{
		return 80 + (1630.7 - resist)/42.66;
     890:	a7 01       	movw	r20, r14
     892:	96 01       	movw	r18, r12
     894:	66 e6       	ldi	r22, 0x66	; 102
     896:	76 ed       	ldi	r23, 0xD6	; 214
     898:	8b ec       	ldi	r24, 0xCB	; 203
     89a:	94 e4       	ldi	r25, 0x44	; 68
     89c:	0e 94 be 0b 	call	0x177c	; 0x177c <__subsf3>
     8a0:	27 ed       	ldi	r18, 0xD7	; 215
     8a2:	33 ea       	ldi	r19, 0xA3	; 163
     8a4:	4a e2       	ldi	r20, 0x2A	; 42
     8a6:	52 e4       	ldi	r21, 0x42	; 66
     8a8:	0e 94 30 0c 	call	0x1860	; 0x1860 <__divsf3>
     8ac:	20 e0       	ldi	r18, 0x00	; 0
     8ae:	30 e0       	ldi	r19, 0x00	; 0
     8b0:	40 ea       	ldi	r20, 0xA0	; 160
     8b2:	52 e4       	ldi	r21, 0x42	; 66
     8b4:	0e 94 bf 0b 	call	0x177e	; 0x177e <__addsf3>
     8b8:	3d c2       	rjmp	.+1146   	; 0xd34 <__stack+0x235>
		}
		*/
	}
	
	// 85°C to 90°C range:
	else if (resist <= 1417.4 && resist > 1236.2)
     8ba:	2d ec       	ldi	r18, 0xCD	; 205
     8bc:	3c e2       	ldi	r19, 0x2C	; 44
     8be:	41 eb       	ldi	r20, 0xB1	; 177
     8c0:	54 e4       	ldi	r21, 0x44	; 68
     8c2:	c7 01       	movw	r24, r14
     8c4:	b6 01       	movw	r22, r12
     8c6:	0e 94 2b 0c 	call	0x1856	; 0x1856 <__cmpsf2>
     8ca:	18 16       	cp	r1, r24
     8cc:	fc f0       	brlt	.+62     	; 0x90c <convertTemp+0x7de>
     8ce:	26 e6       	ldi	r18, 0x66	; 102
     8d0:	36 e8       	ldi	r19, 0x86	; 134
     8d2:	4a e9       	ldi	r20, 0x9A	; 154
     8d4:	54 e4       	ldi	r21, 0x44	; 68
     8d6:	c7 01       	movw	r24, r14
     8d8:	b6 01       	movw	r22, r12
     8da:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <__gesf2>
     8de:	18 16       	cp	r1, r24
     8e0:	ac f4       	brge	.+42     	; 0x90c <convertTemp+0x7de>
	{
		return 85 + (1417.4 - resist)/36.24;
     8e2:	a7 01       	movw	r20, r14
     8e4:	96 01       	movw	r18, r12
     8e6:	6d ec       	ldi	r22, 0xCD	; 205
     8e8:	7c e2       	ldi	r23, 0x2C	; 44
     8ea:	81 eb       	ldi	r24, 0xB1	; 177
     8ec:	94 e4       	ldi	r25, 0x44	; 68
     8ee:	0e 94 be 0b 	call	0x177c	; 0x177c <__subsf3>
     8f2:	23 ec       	ldi	r18, 0xC3	; 195
     8f4:	35 ef       	ldi	r19, 0xF5	; 245
     8f6:	40 e1       	ldi	r20, 0x10	; 16
     8f8:	52 e4       	ldi	r21, 0x42	; 66
     8fa:	0e 94 30 0c 	call	0x1860	; 0x1860 <__divsf3>
     8fe:	20 e0       	ldi	r18, 0x00	; 0
     900:	30 e0       	ldi	r19, 0x00	; 0
     902:	4a ea       	ldi	r20, 0xAA	; 170
     904:	52 e4       	ldi	r21, 0x42	; 66
     906:	0e 94 bf 0b 	call	0x177e	; 0x177e <__addsf3>
     90a:	14 c2       	rjmp	.+1064   	; 0xd34 <__stack+0x235>
		}
		*/
	}
	
	// 90°C to 95°C range:
	else if (resist <= 1236.2 && resist > 1081.8)
     90c:	26 e6       	ldi	r18, 0x66	; 102
     90e:	36 e8       	ldi	r19, 0x86	; 134
     910:	4a e9       	ldi	r20, 0x9A	; 154
     912:	54 e4       	ldi	r21, 0x44	; 68
     914:	c7 01       	movw	r24, r14
     916:	b6 01       	movw	r22, r12
     918:	0e 94 2b 0c 	call	0x1856	; 0x1856 <__cmpsf2>
     91c:	18 16       	cp	r1, r24
     91e:	fc f0       	brlt	.+62     	; 0x95e <convertTemp+0x830>
     920:	2a e9       	ldi	r18, 0x9A	; 154
     922:	39 e3       	ldi	r19, 0x39	; 57
     924:	47 e8       	ldi	r20, 0x87	; 135
     926:	54 e4       	ldi	r21, 0x44	; 68
     928:	c7 01       	movw	r24, r14
     92a:	b6 01       	movw	r22, r12
     92c:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <__gesf2>
     930:	18 16       	cp	r1, r24
     932:	ac f4       	brge	.+42     	; 0x95e <convertTemp+0x830>
	{
		return 90 + (1236.2 - resist)/30.88;
     934:	a7 01       	movw	r20, r14
     936:	96 01       	movw	r18, r12
     938:	66 e6       	ldi	r22, 0x66	; 102
     93a:	76 e8       	ldi	r23, 0x86	; 134
     93c:	8a e9       	ldi	r24, 0x9A	; 154
     93e:	94 e4       	ldi	r25, 0x44	; 68
     940:	0e 94 be 0b 	call	0x177c	; 0x177c <__subsf3>
     944:	2d e3       	ldi	r18, 0x3D	; 61
     946:	3a e0       	ldi	r19, 0x0A	; 10
     948:	47 ef       	ldi	r20, 0xF7	; 247
     94a:	51 e4       	ldi	r21, 0x41	; 65
     94c:	0e 94 30 0c 	call	0x1860	; 0x1860 <__divsf3>
     950:	20 e0       	ldi	r18, 0x00	; 0
     952:	30 e0       	ldi	r19, 0x00	; 0
     954:	44 eb       	ldi	r20, 0xB4	; 180
     956:	52 e4       	ldi	r21, 0x42	; 66
     958:	0e 94 bf 0b 	call	0x177e	; 0x177e <__addsf3>
     95c:	eb c1       	rjmp	.+982    	; 0xd34 <__stack+0x235>
		}
		*/
	}
	
	// 95°C to 100°C range:
	else if (resist <= 1081.8 && resist > 949.73)
     95e:	2a e9       	ldi	r18, 0x9A	; 154
     960:	39 e3       	ldi	r19, 0x39	; 57
     962:	47 e8       	ldi	r20, 0x87	; 135
     964:	54 e4       	ldi	r21, 0x44	; 68
     966:	c7 01       	movw	r24, r14
     968:	b6 01       	movw	r22, r12
     96a:	0e 94 2b 0c 	call	0x1856	; 0x1856 <__cmpsf2>
     96e:	18 16       	cp	r1, r24
     970:	fc f0       	brlt	.+62     	; 0x9b0 <convertTemp+0x882>
     972:	28 eb       	ldi	r18, 0xB8	; 184
     974:	3e e6       	ldi	r19, 0x6E	; 110
     976:	4d e6       	ldi	r20, 0x6D	; 109
     978:	54 e4       	ldi	r21, 0x44	; 68
     97a:	c7 01       	movw	r24, r14
     97c:	b6 01       	movw	r22, r12
     97e:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <__gesf2>
     982:	18 16       	cp	r1, r24
     984:	ac f4       	brge	.+42     	; 0x9b0 <convertTemp+0x882>
	{
		return 95 + (1081.8 - resist)/26.414;
     986:	a7 01       	movw	r20, r14
     988:	96 01       	movw	r18, r12
     98a:	6a e9       	ldi	r22, 0x9A	; 154
     98c:	79 e3       	ldi	r23, 0x39	; 57
     98e:	87 e8       	ldi	r24, 0x87	; 135
     990:	94 e4       	ldi	r25, 0x44	; 68
     992:	0e 94 be 0b 	call	0x177c	; 0x177c <__subsf3>
     996:	2f ed       	ldi	r18, 0xDF	; 223
     998:	3f e4       	ldi	r19, 0x4F	; 79
     99a:	43 ed       	ldi	r20, 0xD3	; 211
     99c:	51 e4       	ldi	r21, 0x41	; 65
     99e:	0e 94 30 0c 	call	0x1860	; 0x1860 <__divsf3>
     9a2:	20 e0       	ldi	r18, 0x00	; 0
     9a4:	30 e0       	ldi	r19, 0x00	; 0
     9a6:	4e eb       	ldi	r20, 0xBE	; 190
     9a8:	52 e4       	ldi	r21, 0x42	; 66
     9aa:	0e 94 bf 0b 	call	0x177e	; 0x177e <__addsf3>
     9ae:	c2 c1       	rjmp	.+900    	; 0xd34 <__stack+0x235>
	/*******************************************************************************************************************
	********************* END PCR RANGE ********************************************************************************
	*******************************************************************************************************************/
	
	// 100°C to 105°C range:
	else if (resist <= 949.73 && resist > 836.4)
     9b0:	28 eb       	ldi	r18, 0xB8	; 184
     9b2:	3e e6       	ldi	r19, 0x6E	; 110
     9b4:	4d e6       	ldi	r20, 0x6D	; 109
     9b6:	54 e4       	ldi	r21, 0x44	; 68
     9b8:	c7 01       	movw	r24, r14
     9ba:	b6 01       	movw	r22, r12
     9bc:	0e 94 2b 0c 	call	0x1856	; 0x1856 <__cmpsf2>
     9c0:	18 16       	cp	r1, r24
     9c2:	5c f0       	brlt	.+22     	; 0x9da <convertTemp+0x8ac>
     9c4:	2a e9       	ldi	r18, 0x9A	; 154
     9c6:	39 e1       	ldi	r19, 0x19	; 25
     9c8:	41 e5       	ldi	r20, 0x51	; 81
     9ca:	54 e4       	ldi	r21, 0x44	; 68
     9cc:	c7 01       	movw	r24, r14
     9ce:	b6 01       	movw	r22, r12
     9d0:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <__gesf2>
     9d4:	18 16       	cp	r1, r24
     9d6:	0c f4       	brge	.+2      	; 0x9da <convertTemp+0x8ac>
     9d8:	4a c1       	rjmp	.+660    	; 0xc6e <__stack+0x16f>
	{
		return 100;
	}
	
	// 105°C to 110°C range:
	else if (resist <= 836.4 && resist > 738.81)
     9da:	2a e9       	ldi	r18, 0x9A	; 154
     9dc:	39 e1       	ldi	r19, 0x19	; 25
     9de:	41 e5       	ldi	r20, 0x51	; 81
     9e0:	54 e4       	ldi	r21, 0x44	; 68
     9e2:	c7 01       	movw	r24, r14
     9e4:	b6 01       	movw	r22, r12
     9e6:	0e 94 2b 0c 	call	0x1856	; 0x1856 <__cmpsf2>
     9ea:	18 16       	cp	r1, r24
     9ec:	5c f0       	brlt	.+22     	; 0xa04 <convertTemp+0x8d6>
     9ee:	27 ed       	ldi	r18, 0xD7	; 215
     9f0:	33 eb       	ldi	r19, 0xB3	; 179
     9f2:	48 e3       	ldi	r20, 0x38	; 56
     9f4:	54 e4       	ldi	r21, 0x44	; 68
     9f6:	c7 01       	movw	r24, r14
     9f8:	b6 01       	movw	r22, r12
     9fa:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <__gesf2>
     9fe:	18 16       	cp	r1, r24
     a00:	0c f4       	brge	.+2      	; 0xa04 <convertTemp+0x8d6>
     a02:	3a c1       	rjmp	.+628    	; 0xc78 <__stack+0x179>
	{
		return 105;
	}
	
	// 110°C to 115°C range:
	else if (resist <= 738.81 && resist > 654.5)
     a04:	27 ed       	ldi	r18, 0xD7	; 215
     a06:	33 eb       	ldi	r19, 0xB3	; 179
     a08:	48 e3       	ldi	r20, 0x38	; 56
     a0a:	54 e4       	ldi	r21, 0x44	; 68
     a0c:	c7 01       	movw	r24, r14
     a0e:	b6 01       	movw	r22, r12
     a10:	0e 94 2b 0c 	call	0x1856	; 0x1856 <__cmpsf2>
     a14:	18 16       	cp	r1, r24
     a16:	5c f0       	brlt	.+22     	; 0xa2e <convertTemp+0x900>
     a18:	20 e0       	ldi	r18, 0x00	; 0
     a1a:	30 ea       	ldi	r19, 0xA0	; 160
     a1c:	43 e2       	ldi	r20, 0x23	; 35
     a1e:	54 e4       	ldi	r21, 0x44	; 68
     a20:	c7 01       	movw	r24, r14
     a22:	b6 01       	movw	r22, r12
     a24:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <__gesf2>
     a28:	18 16       	cp	r1, r24
     a2a:	0c f4       	brge	.+2      	; 0xa2e <convertTemp+0x900>
     a2c:	2a c1       	rjmp	.+596    	; 0xc82 <__stack+0x183>
	{
		return 110;
	}
	
	// 115°C to 120°C range:
	else if (resist <= 654.5 && resist > 581.44)
     a2e:	20 e0       	ldi	r18, 0x00	; 0
     a30:	30 ea       	ldi	r19, 0xA0	; 160
     a32:	43 e2       	ldi	r20, 0x23	; 35
     a34:	54 e4       	ldi	r21, 0x44	; 68
     a36:	c7 01       	movw	r24, r14
     a38:	b6 01       	movw	r22, r12
     a3a:	0e 94 2b 0c 	call	0x1856	; 0x1856 <__cmpsf2>
     a3e:	18 16       	cp	r1, r24
     a40:	5c f0       	brlt	.+22     	; 0xa58 <convertTemp+0x92a>
     a42:	29 e2       	ldi	r18, 0x29	; 41
     a44:	3c e5       	ldi	r19, 0x5C	; 92
     a46:	41 e1       	ldi	r20, 0x11	; 17
     a48:	54 e4       	ldi	r21, 0x44	; 68
     a4a:	c7 01       	movw	r24, r14
     a4c:	b6 01       	movw	r22, r12
     a4e:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <__gesf2>
     a52:	18 16       	cp	r1, r24
     a54:	0c f4       	brge	.+2      	; 0xa58 <convertTemp+0x92a>
     a56:	1a c1       	rjmp	.+564    	; 0xc8c <__stack+0x18d>
	{
		return 115;
	}
	
	// 120°C to 125°C range:
	else if (resist <= 581.44 && resist > 517.94)
     a58:	29 e2       	ldi	r18, 0x29	; 41
     a5a:	3c e5       	ldi	r19, 0x5C	; 92
     a5c:	41 e1       	ldi	r20, 0x11	; 17
     a5e:	54 e4       	ldi	r21, 0x44	; 68
     a60:	c7 01       	movw	r24, r14
     a62:	b6 01       	movw	r22, r12
     a64:	0e 94 2b 0c 	call	0x1856	; 0x1856 <__cmpsf2>
     a68:	18 16       	cp	r1, r24
     a6a:	5c f0       	brlt	.+22     	; 0xa82 <convertTemp+0x954>
     a6c:	29 e2       	ldi	r18, 0x29	; 41
     a6e:	3c e7       	ldi	r19, 0x7C	; 124
     a70:	41 e0       	ldi	r20, 0x01	; 1
     a72:	54 e4       	ldi	r21, 0x44	; 68
     a74:	c7 01       	movw	r24, r14
     a76:	b6 01       	movw	r22, r12
     a78:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <__gesf2>
     a7c:	18 16       	cp	r1, r24
     a7e:	0c f4       	brge	.+2      	; 0xa82 <convertTemp+0x954>
     a80:	0a c1       	rjmp	.+532    	; 0xc96 <__stack+0x197>
	{
		return 120;
	}
	
	// 125°C to 130°C range:
	else if (resist <= 517.94 && resist > 462.59)
     a82:	29 e2       	ldi	r18, 0x29	; 41
     a84:	3c e7       	ldi	r19, 0x7C	; 124
     a86:	41 e0       	ldi	r20, 0x01	; 1
     a88:	54 e4       	ldi	r21, 0x44	; 68
     a8a:	c7 01       	movw	r24, r14
     a8c:	b6 01       	movw	r22, r12
     a8e:	0e 94 2b 0c 	call	0x1856	; 0x1856 <__cmpsf2>
     a92:	18 16       	cp	r1, r24
     a94:	5c f0       	brlt	.+22     	; 0xaac <convertTemp+0x97e>
     a96:	25 e8       	ldi	r18, 0x85	; 133
     a98:	3b e4       	ldi	r19, 0x4B	; 75
     a9a:	47 ee       	ldi	r20, 0xE7	; 231
     a9c:	53 e4       	ldi	r21, 0x43	; 67
     a9e:	c7 01       	movw	r24, r14
     aa0:	b6 01       	movw	r22, r12
     aa2:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <__gesf2>
     aa6:	18 16       	cp	r1, r24
     aa8:	0c f4       	brge	.+2      	; 0xaac <convertTemp+0x97e>
     aaa:	fa c0       	rjmp	.+500    	; 0xca0 <__stack+0x1a1>
	{
		return 125;
	}
	
	// 130°C to 135°C range:
	else if (resist <= 462.59 && resist > 414.2)
     aac:	25 e8       	ldi	r18, 0x85	; 133
     aae:	3b e4       	ldi	r19, 0x4B	; 75
     ab0:	47 ee       	ldi	r20, 0xE7	; 231
     ab2:	53 e4       	ldi	r21, 0x43	; 67
     ab4:	c7 01       	movw	r24, r14
     ab6:	b6 01       	movw	r22, r12
     ab8:	0e 94 2b 0c 	call	0x1856	; 0x1856 <__cmpsf2>
     abc:	18 16       	cp	r1, r24
     abe:	5c f0       	brlt	.+22     	; 0xad6 <convertTemp+0x9a8>
     ac0:	2a e9       	ldi	r18, 0x9A	; 154
     ac2:	39 e1       	ldi	r19, 0x19	; 25
     ac4:	4f ec       	ldi	r20, 0xCF	; 207
     ac6:	53 e4       	ldi	r21, 0x43	; 67
     ac8:	c7 01       	movw	r24, r14
     aca:	b6 01       	movw	r22, r12
     acc:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <__gesf2>
     ad0:	18 16       	cp	r1, r24
     ad2:	0c f4       	brge	.+2      	; 0xad6 <convertTemp+0x9a8>
     ad4:	ea c0       	rjmp	.+468    	; 0xcaa <__stack+0x1ab>
	{
		return 130;
	}
	
	// 135°C to 140°C range:
	else if (resist <= 414.2 && resist > 371.79)
     ad6:	2a e9       	ldi	r18, 0x9A	; 154
     ad8:	39 e1       	ldi	r19, 0x19	; 25
     ada:	4f ec       	ldi	r20, 0xCF	; 207
     adc:	53 e4       	ldi	r21, 0x43	; 67
     ade:	c7 01       	movw	r24, r14
     ae0:	b6 01       	movw	r22, r12
     ae2:	0e 94 2b 0c 	call	0x1856	; 0x1856 <__cmpsf2>
     ae6:	18 16       	cp	r1, r24
     ae8:	5c f0       	brlt	.+22     	; 0xb00 <__stack+0x1>
     aea:	2f e1       	ldi	r18, 0x1F	; 31
     aec:	35 ee       	ldi	r19, 0xE5	; 229
     aee:	49 eb       	ldi	r20, 0xB9	; 185
     af0:	53 e4       	ldi	r21, 0x43	; 67
     af2:	c7 01       	movw	r24, r14
     af4:	b6 01       	movw	r22, r12
     af6:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <__gesf2>
     afa:	18 16       	cp	r1, r24
     afc:	0c f4       	brge	.+2      	; 0xb00 <__stack+0x1>
     afe:	da c0       	rjmp	.+436    	; 0xcb4 <__stack+0x1b5>
	{
		return 135;
	}
	
	// 140°C to 145°C range:
	else if (resist <= 371.79 && resist > 334.51)
     b00:	2f e1       	ldi	r18, 0x1F	; 31
     b02:	35 ee       	ldi	r19, 0xE5	; 229
     b04:	49 eb       	ldi	r20, 0xB9	; 185
     b06:	53 e4       	ldi	r21, 0x43	; 67
     b08:	c7 01       	movw	r24, r14
     b0a:	b6 01       	movw	r22, r12
     b0c:	0e 94 2b 0c 	call	0x1856	; 0x1856 <__cmpsf2>
     b10:	18 16       	cp	r1, r24
     b12:	5c f0       	brlt	.+22     	; 0xb2a <__stack+0x2b>
     b14:	28 e4       	ldi	r18, 0x48	; 72
     b16:	31 e4       	ldi	r19, 0x41	; 65
     b18:	47 ea       	ldi	r20, 0xA7	; 167
     b1a:	53 e4       	ldi	r21, 0x43	; 67
     b1c:	c7 01       	movw	r24, r14
     b1e:	b6 01       	movw	r22, r12
     b20:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <__gesf2>
     b24:	18 16       	cp	r1, r24
     b26:	0c f4       	brge	.+2      	; 0xb2a <__stack+0x2b>
     b28:	ca c0       	rjmp	.+404    	; 0xcbe <__stack+0x1bf>
	{
		return 140;
	}
	
	// 145°C to 150°C range:
	else if (resist <= 334.51 && resist > 301.66)
     b2a:	28 e4       	ldi	r18, 0x48	; 72
     b2c:	31 e4       	ldi	r19, 0x41	; 65
     b2e:	47 ea       	ldi	r20, 0xA7	; 167
     b30:	53 e4       	ldi	r21, 0x43	; 67
     b32:	c7 01       	movw	r24, r14
     b34:	b6 01       	movw	r22, r12
     b36:	0e 94 2b 0c 	call	0x1856	; 0x1856 <__cmpsf2>
     b3a:	18 16       	cp	r1, r24
     b3c:	5c f0       	brlt	.+22     	; 0xb54 <__stack+0x55>
     b3e:	2b e7       	ldi	r18, 0x7B	; 123
     b40:	34 ed       	ldi	r19, 0xD4	; 212
     b42:	46 e9       	ldi	r20, 0x96	; 150
     b44:	53 e4       	ldi	r21, 0x43	; 67
     b46:	c7 01       	movw	r24, r14
     b48:	b6 01       	movw	r22, r12
     b4a:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <__gesf2>
     b4e:	18 16       	cp	r1, r24
     b50:	0c f4       	brge	.+2      	; 0xb54 <__stack+0x55>
     b52:	ba c0       	rjmp	.+372    	; 0xcc8 <__stack+0x1c9>
	{
		return 145;
	}
	
	// 150°C to 155°C range:
	else if (resist <= 301.66 && resist > 272.64)
     b54:	2b e7       	ldi	r18, 0x7B	; 123
     b56:	34 ed       	ldi	r19, 0xD4	; 212
     b58:	46 e9       	ldi	r20, 0x96	; 150
     b5a:	53 e4       	ldi	r21, 0x43	; 67
     b5c:	c7 01       	movw	r24, r14
     b5e:	b6 01       	movw	r22, r12
     b60:	0e 94 2b 0c 	call	0x1856	; 0x1856 <__cmpsf2>
     b64:	18 16       	cp	r1, r24
     b66:	0c f4       	brge	.+2      	; 0xb6a <__stack+0x6b>
     b68:	b4 c0       	rjmp	.+360    	; 0xcd2 <__stack+0x1d3>
     b6a:	2c ee       	ldi	r18, 0xEC	; 236
     b6c:	31 e5       	ldi	r19, 0x51	; 81
     b6e:	48 e8       	ldi	r20, 0x88	; 136
     b70:	53 e4       	ldi	r21, 0x43	; 67
     b72:	c7 01       	movw	r24, r14
     b74:	b6 01       	movw	r22, r12
     b76:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <__gesf2>
     b7a:	18 16       	cp	r1, r24
     b7c:	0c f0       	brlt	.+2      	; 0xb80 <__stack+0x81>
     b7e:	ae c0       	rjmp	.+348    	; 0xcdc <__stack+0x1dd>
	{
		return 150;
     b80:	60 e0       	ldi	r22, 0x00	; 0
     b82:	70 e0       	ldi	r23, 0x00	; 0
     b84:	86 e1       	ldi	r24, 0x16	; 22
     b86:	93 e4       	ldi	r25, 0x43	; 67
     b88:	d5 c0       	rjmp	.+426    	; 0xd34 <__stack+0x235>
	

	// -55°C to -50°C range:
	if (resist <= 526240 && resist > 384520)
	{
		return -55;
     b8a:	60 e0       	ldi	r22, 0x00	; 0
     b8c:	70 e0       	ldi	r23, 0x00	; 0
     b8e:	8c e5       	ldi	r24, 0x5C	; 92
     b90:	92 ec       	ldi	r25, 0xC2	; 194
     b92:	d0 c0       	rjmp	.+416    	; 0xd34 <__stack+0x235>
	}
	
	// -50°C to -45°C range:
	else if (resist <= 384520 && resist > 284010)
	{
		return -50;
     b94:	60 e0       	ldi	r22, 0x00	; 0
     b96:	70 e0       	ldi	r23, 0x00	; 0
     b98:	88 e4       	ldi	r24, 0x48	; 72
     b9a:	92 ec       	ldi	r25, 0xC2	; 194
     b9c:	cb c0       	rjmp	.+406    	; 0xd34 <__stack+0x235>
	}
	
	// -45°C to -40°C range:
	else if (resist <= 284010 && resist > 211940)
	{
		return -45;
     b9e:	60 e0       	ldi	r22, 0x00	; 0
     ba0:	70 e0       	ldi	r23, 0x00	; 0
     ba2:	84 e3       	ldi	r24, 0x34	; 52
     ba4:	92 ec       	ldi	r25, 0xC2	; 194
     ba6:	c6 c0       	rjmp	.+396    	; 0xd34 <__stack+0x235>
	}
	
	// -40°C to -35°C range:
	else if (resist <= 211940 && resist > 159720)
	{
		return -40;
     ba8:	60 e0       	ldi	r22, 0x00	; 0
     baa:	70 e0       	ldi	r23, 0x00	; 0
     bac:	80 e2       	ldi	r24, 0x20	; 32
     bae:	92 ec       	ldi	r25, 0xC2	; 194
     bb0:	c1 c0       	rjmp	.+386    	; 0xd34 <__stack+0x235>
	}
	
	// -35°C to -30°C range:
	else if (resist <= 159720 && resist > 121490)
	{
		return -35;
     bb2:	60 e0       	ldi	r22, 0x00	; 0
     bb4:	70 e0       	ldi	r23, 0x00	; 0
     bb6:	8c e0       	ldi	r24, 0x0C	; 12
     bb8:	92 ec       	ldi	r25, 0xC2	; 194
     bba:	bc c0       	rjmp	.+376    	; 0xd34 <__stack+0x235>
	}
	
	// -30°C to -25°C range:
	else if (resist <= 121490 && resist > 93246)
	{
		return -30;
     bbc:	60 e0       	ldi	r22, 0x00	; 0
     bbe:	70 e0       	ldi	r23, 0x00	; 0
     bc0:	80 ef       	ldi	r24, 0xF0	; 240
     bc2:	91 ec       	ldi	r25, 0xC1	; 193
     bc4:	b7 c0       	rjmp	.+366    	; 0xd34 <__stack+0x235>
	}
	
	// -25°C to -20°C range:
	else if (resist <= 93246 && resist > 72181)
	{
		return -25;
     bc6:	60 e0       	ldi	r22, 0x00	; 0
     bc8:	70 e0       	ldi	r23, 0x00	; 0
     bca:	88 ec       	ldi	r24, 0xC8	; 200
     bcc:	91 ec       	ldi	r25, 0xC1	; 193
     bce:	b2 c0       	rjmp	.+356    	; 0xd34 <__stack+0x235>
	}
	
	// -20°C to -15°C range:
	else if (resist <= 72181 && resist > 56332)
	{
		return -20;
     bd0:	60 e0       	ldi	r22, 0x00	; 0
     bd2:	70 e0       	ldi	r23, 0x00	; 0
     bd4:	80 ea       	ldi	r24, 0xA0	; 160
     bd6:	91 ec       	ldi	r25, 0xC1	; 193
     bd8:	ad c0       	rjmp	.+346    	; 0xd34 <__stack+0x235>
	}
	
	// -15°C to -10°C range:
	else if (resist <= 56332 && resist > 44308)
	{
		return -15;
     bda:	60 e0       	ldi	r22, 0x00	; 0
     bdc:	70 e0       	ldi	r23, 0x00	; 0
     bde:	80 e7       	ldi	r24, 0x70	; 112
     be0:	91 ec       	ldi	r25, 0xC1	; 193
     be2:	a8 c0       	rjmp	.+336    	; 0xd34 <__stack+0x235>
	}
	
	// -10°C to -5°C range:
	else if (resist <= 44308 && resist > 35112)
	{
		return -10;
     be4:	60 e0       	ldi	r22, 0x00	; 0
     be6:	70 e0       	ldi	r23, 0x00	; 0
     be8:	80 e2       	ldi	r24, 0x20	; 32
     bea:	91 ec       	ldi	r25, 0xC1	; 193
     bec:	a3 c0       	rjmp	.+326    	; 0xd34 <__stack+0x235>
	}
	
	// -5°C to 0°C range:
	else if (resist <= 35112 && resist > 28024)
	{
		return -5;
     bee:	60 e0       	ldi	r22, 0x00	; 0
     bf0:	70 e0       	ldi	r23, 0x00	; 0
     bf2:	80 ea       	ldi	r24, 0xA0	; 160
     bf4:	90 ec       	ldi	r25, 0xC0	; 192
     bf6:	9e c0       	rjmp	.+316    	; 0xd34 <__stack+0x235>
	}
	
	// 0°C to 5°C range:
	else if (resist <= 28024 && resist > 22520)
	{
		return 0;
     bf8:	60 e0       	ldi	r22, 0x00	; 0
     bfa:	70 e0       	ldi	r23, 0x00	; 0
     bfc:	cb 01       	movw	r24, r22
     bfe:	9a c0       	rjmp	.+308    	; 0xd34 <__stack+0x235>
	}
	
	// 5°C to 10°C range:
	else if (resist <= 22520 && resist > 18216)
	{
		return 5;
     c00:	60 e0       	ldi	r22, 0x00	; 0
     c02:	70 e0       	ldi	r23, 0x00	; 0
     c04:	80 ea       	ldi	r24, 0xA0	; 160
     c06:	90 e4       	ldi	r25, 0x40	; 64
     c08:	95 c0       	rjmp	.+298    	; 0xd34 <__stack+0x235>
	}
	
	// 10°C to 15°C range:
	else if (resist <= 18216 && resist > 14827)
	{
		return 10;
     c0a:	60 e0       	ldi	r22, 0x00	; 0
     c0c:	70 e0       	ldi	r23, 0x00	; 0
     c0e:	80 e2       	ldi	r24, 0x20	; 32
     c10:	91 e4       	ldi	r25, 0x41	; 65
     c12:	90 c0       	rjmp	.+288    	; 0xd34 <__stack+0x235>
	}
	
	// 15°C to 20°C range:
	else if (resist <= 14827 && resist > 12142)
	{
		return 15;
     c14:	60 e0       	ldi	r22, 0x00	; 0
     c16:	70 e0       	ldi	r23, 0x00	; 0
     c18:	80 e7       	ldi	r24, 0x70	; 112
     c1a:	91 e4       	ldi	r25, 0x41	; 65
     c1c:	8b c0       	rjmp	.+278    	; 0xd34 <__stack+0x235>
	// 20°C to 25°C range:
	else if (resist <= 12142 && resist > 10000)
	{
		if (resist <= 12142 && resist > 11713.6)// 12142-10000 = 2142 & 2142/5 = 428.4
		{
		return 20;
     c1e:	60 e0       	ldi	r22, 0x00	; 0
     c20:	70 e0       	ldi	r23, 0x00	; 0
     c22:	80 ea       	ldi	r24, 0xA0	; 160
     c24:	91 e4       	ldi	r25, 0x41	; 65
     c26:	86 c0       	rjmp	.+268    	; 0xd34 <__stack+0x235>
		}
		else if (resist <= 11713.6 && resist > 11285.2)
		{
			return 21;
     c28:	60 e0       	ldi	r22, 0x00	; 0
     c2a:	70 e0       	ldi	r23, 0x00	; 0
     c2c:	88 ea       	ldi	r24, 0xA8	; 168
     c2e:	91 e4       	ldi	r25, 0x41	; 65
     c30:	81 c0       	rjmp	.+258    	; 0xd34 <__stack+0x235>
		}
		else if (resist <= 11285.2 && resist > 10856.8)
		{
			return 22;
     c32:	60 e0       	ldi	r22, 0x00	; 0
     c34:	70 e0       	ldi	r23, 0x00	; 0
     c36:	80 eb       	ldi	r24, 0xB0	; 176
     c38:	91 e4       	ldi	r25, 0x41	; 65
     c3a:	7c c0       	rjmp	.+248    	; 0xd34 <__stack+0x235>
		}
		else if (resist <= 10856.8 && resist > 10428.4)
		{
			return 23;
     c3c:	60 e0       	ldi	r22, 0x00	; 0
     c3e:	70 e0       	ldi	r23, 0x00	; 0
     c40:	88 eb       	ldi	r24, 0xB8	; 184
     c42:	91 e4       	ldi	r25, 0x41	; 65
     c44:	77 c0       	rjmp	.+238    	; 0xd34 <__stack+0x235>
	// 25°C to 30°C range:
	else if (resist <= 10000 && resist > 8281.8)
	{
		if (resist <= 10000 && resist > 9656.36) // 10000-8281.8 = 1718.2 & 1718.2/5 = 343.64
		{
		return 25;
     c46:	60 e0       	ldi	r22, 0x00	; 0
     c48:	70 e0       	ldi	r23, 0x00	; 0
     c4a:	88 ec       	ldi	r24, 0xC8	; 200
     c4c:	91 e4       	ldi	r25, 0x41	; 65
     c4e:	72 c0       	rjmp	.+228    	; 0xd34 <__stack+0x235>
		}
		else if (resist <= 9656.36 && resist > 9312.72)
		{
			return 26;
     c50:	60 e0       	ldi	r22, 0x00	; 0
     c52:	70 e0       	ldi	r23, 0x00	; 0
     c54:	80 ed       	ldi	r24, 0xD0	; 208
     c56:	91 e4       	ldi	r25, 0x41	; 65
     c58:	6d c0       	rjmp	.+218    	; 0xd34 <__stack+0x235>
		}
		else if (resist <= 9312.72 && resist > 8969.08)
		{
			return 27;
     c5a:	60 e0       	ldi	r22, 0x00	; 0
     c5c:	70 e0       	ldi	r23, 0x00	; 0
     c5e:	88 ed       	ldi	r24, 0xD8	; 216
     c60:	91 e4       	ldi	r25, 0x41	; 65
     c62:	68 c0       	rjmp	.+208    	; 0xd34 <__stack+0x235>
		}
		else if (resist <= 8969.08 && resist > 8625.44)
		{
			return 28;
     c64:	60 e0       	ldi	r22, 0x00	; 0
     c66:	70 e0       	ldi	r23, 0x00	; 0
     c68:	80 ee       	ldi	r24, 0xE0	; 224
     c6a:	91 e4       	ldi	r25, 0x41	; 65
     c6c:	63 c0       	rjmp	.+198    	; 0xd34 <__stack+0x235>
	*******************************************************************************************************************/
	
	// 100°C to 105°C range:
	else if (resist <= 949.73 && resist > 836.4)
	{
		return 100;
     c6e:	60 e0       	ldi	r22, 0x00	; 0
     c70:	70 e0       	ldi	r23, 0x00	; 0
     c72:	88 ec       	ldi	r24, 0xC8	; 200
     c74:	92 e4       	ldi	r25, 0x42	; 66
     c76:	5e c0       	rjmp	.+188    	; 0xd34 <__stack+0x235>
	}
	
	// 105°C to 110°C range:
	else if (resist <= 836.4 && resist > 738.81)
	{
		return 105;
     c78:	60 e0       	ldi	r22, 0x00	; 0
     c7a:	70 e0       	ldi	r23, 0x00	; 0
     c7c:	82 ed       	ldi	r24, 0xD2	; 210
     c7e:	92 e4       	ldi	r25, 0x42	; 66
     c80:	59 c0       	rjmp	.+178    	; 0xd34 <__stack+0x235>
	}
	
	// 110°C to 115°C range:
	else if (resist <= 738.81 && resist > 654.5)
	{
		return 110;
     c82:	60 e0       	ldi	r22, 0x00	; 0
     c84:	70 e0       	ldi	r23, 0x00	; 0
     c86:	8c ed       	ldi	r24, 0xDC	; 220
     c88:	92 e4       	ldi	r25, 0x42	; 66
     c8a:	54 c0       	rjmp	.+168    	; 0xd34 <__stack+0x235>
	}
	
	// 115°C to 120°C range:
	else if (resist <= 654.5 && resist > 581.44)
	{
		return 115;
     c8c:	60 e0       	ldi	r22, 0x00	; 0
     c8e:	70 e0       	ldi	r23, 0x00	; 0
     c90:	86 ee       	ldi	r24, 0xE6	; 230
     c92:	92 e4       	ldi	r25, 0x42	; 66
     c94:	4f c0       	rjmp	.+158    	; 0xd34 <__stack+0x235>
	}
	
	// 120°C to 125°C range:
	else if (resist <= 581.44 && resist > 517.94)
	{
		return 120;
     c96:	60 e0       	ldi	r22, 0x00	; 0
     c98:	70 e0       	ldi	r23, 0x00	; 0
     c9a:	80 ef       	ldi	r24, 0xF0	; 240
     c9c:	92 e4       	ldi	r25, 0x42	; 66
     c9e:	4a c0       	rjmp	.+148    	; 0xd34 <__stack+0x235>
	}
	
	// 125°C to 130°C range:
	else if (resist <= 517.94 && resist > 462.59)
	{
		return 125;
     ca0:	60 e0       	ldi	r22, 0x00	; 0
     ca2:	70 e0       	ldi	r23, 0x00	; 0
     ca4:	8a ef       	ldi	r24, 0xFA	; 250
     ca6:	92 e4       	ldi	r25, 0x42	; 66
     ca8:	45 c0       	rjmp	.+138    	; 0xd34 <__stack+0x235>
	}
	
	// 130°C to 135°C range:
	else if (resist <= 462.59 && resist > 414.2)
	{
		return 130;
     caa:	60 e0       	ldi	r22, 0x00	; 0
     cac:	70 e0       	ldi	r23, 0x00	; 0
     cae:	82 e0       	ldi	r24, 0x02	; 2
     cb0:	93 e4       	ldi	r25, 0x43	; 67
     cb2:	40 c0       	rjmp	.+128    	; 0xd34 <__stack+0x235>
	}
	
	// 135°C to 140°C range:
	else if (resist <= 414.2 && resist > 371.79)
	{
		return 135;
     cb4:	60 e0       	ldi	r22, 0x00	; 0
     cb6:	70 e0       	ldi	r23, 0x00	; 0
     cb8:	87 e0       	ldi	r24, 0x07	; 7
     cba:	93 e4       	ldi	r25, 0x43	; 67
     cbc:	3b c0       	rjmp	.+118    	; 0xd34 <__stack+0x235>
	}
	
	// 140°C to 145°C range:
	else if (resist <= 371.79 && resist > 334.51)
	{
		return 140;
     cbe:	60 e0       	ldi	r22, 0x00	; 0
     cc0:	70 e0       	ldi	r23, 0x00	; 0
     cc2:	8c e0       	ldi	r24, 0x0C	; 12
     cc4:	93 e4       	ldi	r25, 0x43	; 67
     cc6:	36 c0       	rjmp	.+108    	; 0xd34 <__stack+0x235>
	}
	
	// 145°C to 150°C range:
	else if (resist <= 334.51 && resist > 301.66)
	{
		return 145;
     cc8:	60 e0       	ldi	r22, 0x00	; 0
     cca:	70 e0       	ldi	r23, 0x00	; 0
     ccc:	81 e1       	ldi	r24, 0x11	; 17
     cce:	93 e4       	ldi	r25, 0x43	; 67
     cd0:	31 c0       	rjmp	.+98     	; 0xd34 <__stack+0x235>
	{
		return 150;
	}
	
	//else 
	return 256;
     cd2:	60 e0       	ldi	r22, 0x00	; 0
     cd4:	70 e0       	ldi	r23, 0x00	; 0
     cd6:	80 e8       	ldi	r24, 0x80	; 128
     cd8:	93 e4       	ldi	r25, 0x43	; 67
     cda:	2c c0       	rjmp	.+88     	; 0xd34 <__stack+0x235>
     cdc:	60 e0       	ldi	r22, 0x00	; 0
     cde:	70 e0       	ldi	r23, 0x00	; 0
     ce0:	80 e8       	ldi	r24, 0x80	; 128
     ce2:	93 e4       	ldi	r25, 0x43	; 67
     ce4:	27 c0       	rjmp	.+78     	; 0xd34 <__stack+0x235>
     ce6:	60 e0       	ldi	r22, 0x00	; 0
     ce8:	70 e0       	ldi	r23, 0x00	; 0
     cea:	80 e8       	ldi	r24, 0x80	; 128
     cec:	93 e4       	ldi	r25, 0x43	; 67
     cee:	22 c0       	rjmp	.+68     	; 0xd34 <__stack+0x235>
     cf0:	60 e0       	ldi	r22, 0x00	; 0
     cf2:	70 e0       	ldi	r23, 0x00	; 0
     cf4:	80 e8       	ldi	r24, 0x80	; 128
     cf6:	93 e4       	ldi	r25, 0x43	; 67
     cf8:	1d c0       	rjmp	.+58     	; 0xd34 <__stack+0x235>
		}
		else if (resist <= 10856.8 && resist > 10428.4)
		{
			return 23;
		}
		else if (resist <= 10428.4 && resist > 10000)
     cfa:	2a e9       	ldi	r18, 0x9A	; 154
     cfc:	31 ef       	ldi	r19, 0xF1	; 241
     cfe:	42 e2       	ldi	r20, 0x22	; 34
     d00:	56 e4       	ldi	r21, 0x46	; 70
     d02:	c7 01       	movw	r24, r14
     d04:	b6 01       	movw	r22, r12
     d06:	0e 94 2b 0c 	call	0x1856	; 0x1856 <__cmpsf2>
     d0a:	18 16       	cp	r1, r24
     d0c:	64 f3       	brlt	.-40     	; 0xce6 <__stack+0x1e7>
		{
			return 24;
     d0e:	60 e0       	ldi	r22, 0x00	; 0
     d10:	70 e0       	ldi	r23, 0x00	; 0
     d12:	80 ec       	ldi	r24, 0xC0	; 192
     d14:	91 e4       	ldi	r25, 0x41	; 65
     d16:	0e c0       	rjmp	.+28     	; 0xd34 <__stack+0x235>
		}
		else if (resist <= 8969.08 && resist > 8625.44)
		{
			return 28;
		}
		else if (resist <= 8625.44 && resist > 8281.8)
     d18:	23 ec       	ldi	r18, 0xC3	; 195
     d1a:	35 ec       	ldi	r19, 0xC5	; 197
     d1c:	46 e0       	ldi	r20, 0x06	; 6
     d1e:	56 e4       	ldi	r21, 0x46	; 70
     d20:	c7 01       	movw	r24, r14
     d22:	b6 01       	movw	r22, r12
     d24:	0e 94 2b 0c 	call	0x1856	; 0x1856 <__cmpsf2>
     d28:	18 16       	cp	r1, r24
     d2a:	14 f3       	brlt	.-60     	; 0xcf0 <__stack+0x1f1>
		{
			return 29;
     d2c:	60 e0       	ldi	r22, 0x00	; 0
     d2e:	70 e0       	ldi	r23, 0x00	; 0
     d30:	88 ee       	ldi	r24, 0xE8	; 232
     d32:	91 e4       	ldi	r25, 0x41	; 65
		return 150;
	}
	
	//else 
	return 256;
     d34:	ff 90       	pop	r15
     d36:	ef 90       	pop	r14
     d38:	df 90       	pop	r13
     d3a:	cf 90       	pop	r12
     d3c:	08 95       	ret

00000d3e <convertADC>:
	 
	return (data);
}


double convertADC(double data){
     d3e:	8f 92       	push	r8
     d40:	9f 92       	push	r9
     d42:	af 92       	push	r10
     d44:	bf 92       	push	r11
     d46:	cf 92       	push	r12
     d48:	df 92       	push	r13
     d4a:	ef 92       	push	r14
     d4c:	ff 92       	push	r15
	double offset=0;
	

	/* Vref = 5v, ADC divides 0-5v into 1024 (2^10) sections. Thus each ADC value is 5/1024=0.004833  
	*/
	voltage = data*0.004833; //1024 divisions of Vref in ADC reading
     d4e:	24 e2       	ldi	r18, 0x24	; 36
     d50:	3e e5       	ldi	r19, 0x5E	; 94
     d52:	4e e9       	ldi	r20, 0x9E	; 158
     d54:	5b e3       	ldi	r21, 0x3B	; 59
     d56:	0e 94 8f 0d 	call	0x1b1e	; 0x1b1e <__mulsf3>
     d5a:	6b 01       	movw	r12, r22
     d5c:	7c 01       	movw	r14, r24
	resistance = (-10000* voltage)/(voltage -Vref); // rearange the voltage divider equation to get thermistor resistance.
     d5e:	20 e0       	ldi	r18, 0x00	; 0
     d60:	30 e4       	ldi	r19, 0x40	; 64
     d62:	4c e1       	ldi	r20, 0x1C	; 28
     d64:	56 ec       	ldi	r21, 0xC6	; 198
     d66:	0e 94 8f 0d 	call	0x1b1e	; 0x1b1e <__mulsf3>
     d6a:	4b 01       	movw	r8, r22
     d6c:	5c 01       	movw	r10, r24
     d6e:	20 e0       	ldi	r18, 0x00	; 0
     d70:	30 e0       	ldi	r19, 0x00	; 0
     d72:	40 ea       	ldi	r20, 0xA0	; 160
     d74:	50 e4       	ldi	r21, 0x40	; 64
     d76:	c7 01       	movw	r24, r14
     d78:	b6 01       	movw	r22, r12
     d7a:	0e 94 be 0b 	call	0x177c	; 0x177c <__subsf3>
     d7e:	9b 01       	movw	r18, r22
     d80:	ac 01       	movw	r20, r24
     d82:	c5 01       	movw	r24, r10
     d84:	b4 01       	movw	r22, r8
     d86:	0e 94 30 0c 	call	0x1860	; 0x1860 <__divsf3>
	temp = convertTemp(resistance) + offset; // use look-up table to get temperatures and calibrate with off-set.
     d8a:	0e 94 97 00 	call	0x12e	; 0x12e <convertTemp>
     d8e:	20 e0       	ldi	r18, 0x00	; 0
     d90:	30 e0       	ldi	r19, 0x00	; 0
     d92:	a9 01       	movw	r20, r18
     d94:	0e 94 bf 0b 	call	0x177e	; 0x177e <__addsf3>
	return (temp);	// outputs conversion.
}
     d98:	ff 90       	pop	r15
     d9a:	ef 90       	pop	r14
     d9c:	df 90       	pop	r13
     d9e:	cf 90       	pop	r12
     da0:	bf 90       	pop	r11
     da2:	af 90       	pop	r10
     da4:	9f 90       	pop	r9
     da6:	8f 90       	pop	r8
     da8:	08 95       	ret

00000daa <__vector_17>:
volatile unsigned int count_ms = 0;
volatile unsigned int timerFlag = 0;
volatile unsigned int printFlag = 0;
void Counter_init (void);

ISR(TIMER1_COMPA_vect){
     daa:	1f 92       	push	r1
     dac:	0f 92       	push	r0
     dae:	0f b6       	in	r0, 0x3f	; 63
     db0:	0f 92       	push	r0
     db2:	11 24       	eor	r1, r1
     db4:	8f 93       	push	r24
     db6:	9f 93       	push	r25
	count_ms ++;
     db8:	80 91 92 02 	lds	r24, 0x0292
     dbc:	90 91 93 02 	lds	r25, 0x0293
     dc0:	01 96       	adiw	r24, 0x01	; 1
     dc2:	90 93 93 02 	sts	0x0293, r25
     dc6:	80 93 92 02 	sts	0x0292, r24
	timerFlag = 1;
     dca:	81 e0       	ldi	r24, 0x01	; 1
     dcc:	90 e0       	ldi	r25, 0x00	; 0
     dce:	90 93 91 02 	sts	0x0291, r25
     dd2:	80 93 90 02 	sts	0x0290, r24
	printFlag ++;
     dd6:	80 91 8e 02 	lds	r24, 0x028E
     dda:	90 91 8f 02 	lds	r25, 0x028F
     dde:	01 96       	adiw	r24, 0x01	; 1
     de0:	90 93 8f 02 	sts	0x028F, r25
     de4:	80 93 8e 02 	sts	0x028E, r24
}
     de8:	9f 91       	pop	r25
     dea:	8f 91       	pop	r24
     dec:	0f 90       	pop	r0
     dee:	0f be       	out	0x3f, r0	; 63
     df0:	0f 90       	pop	r0
     df2:	1f 90       	pop	r1
     df4:	18 95       	reti

00000df6 <h_c_init>:



void h_c_init(void){
	
	DDRB |= ((1<<PB1)|(1<<PB2)|(1<<PB3)) ; // Sets the data direction for Port B PB1 (Relay Control), PB2 is Heating PB3 is fan as an output.
     df6:	84 b1       	in	r24, 0x04	; 4
     df8:	8e 60       	ori	r24, 0x0E	; 14
     dfa:	84 b9       	out	0x04, r24	; 4
	DDRF |= (0<<PF0) | (0<<PF1); // Sets the data direction for port F, PF0 (ADC in), PF1 (Low Battery Signal) as an input.
     dfc:	80 b3       	in	r24, 0x10	; 16
     dfe:	80 bb       	out	0x10, r24	; 16
	DDRD |= (1<<6); // Sets the data direction for port D , PD6 (Teensy LED) as an output.
     e00:	56 9a       	sbi	0x0a, 6	; 10
     e02:	08 95       	ret

00000e04 <holdAtTemp>:
}

void holdAtTemp(uint16_t targetTemp, uint16_t targetTime){
     e04:	2f 92       	push	r2
     e06:	3f 92       	push	r3
     e08:	4f 92       	push	r4
     e0a:	5f 92       	push	r5
     e0c:	6f 92       	push	r6
     e0e:	7f 92       	push	r7
     e10:	8f 92       	push	r8
     e12:	9f 92       	push	r9
     e14:	af 92       	push	r10
     e16:	bf 92       	push	r11
     e18:	cf 92       	push	r12
     e1a:	df 92       	push	r13
     e1c:	ef 92       	push	r14
     e1e:	ff 92       	push	r15
     e20:	0f 93       	push	r16
     e22:	1f 93       	push	r17
     e24:	cf 93       	push	r28
     e26:	df 93       	push	r29
     e28:	cd b7       	in	r28, 0x3d	; 61
     e2a:	de b7       	in	r29, 0x3e	; 62
     e2c:	2e 97       	sbiw	r28, 0x0e	; 14
     e2e:	0f b6       	in	r0, 0x3f	; 63
     e30:	f8 94       	cli
     e32:	de bf       	out	0x3e, r29	; 62
     e34:	0f be       	out	0x3f, r0	; 63
     e36:	cd bf       	out	0x3d, r28	; 61
     e38:	3c 01       	movw	r6, r24
     e3a:	2b 01       	movw	r4, r22
	printStr("In hold at temp \n"); //send 
     e3c:	80 e0       	ldi	r24, 0x00	; 0
     e3e:	91 e0       	ldi	r25, 0x01	; 1
     e40:	0e 94 7f 0b 	call	0x16fe	; 0x16fe <printStr>
	double readTemp;
	double temp = 0;
	double avgTemp = 0.0;		
	int numTemps = 0;
	
	count_ms = 0;
     e44:	10 92 93 02 	sts	0x0293, r1
     e48:	10 92 92 02 	sts	0x0292, r1
	printFlag = 0;
     e4c:	10 92 8f 02 	sts	0x028F, r1
     e50:	10 92 8e 02 	sts	0x028E, r1
		
	while(count_ms < 2*targetTime){//count increments at half seconds
     e54:	44 0c       	add	r4, r4
     e56:	55 1c       	adc	r5, r5
	printStr("In hold at temp \n"); //send 
	
	double readTemp;
	double temp = 0;
	double avgTemp = 0.0;		
	int numTemps = 0;
     e58:	21 2c       	mov	r2, r1
     e5a:	31 2c       	mov	r3, r1
void holdAtTemp(uint16_t targetTemp, uint16_t targetTime){
	printStr("In hold at temp \n"); //send 
	
	double readTemp;
	double temp = 0;
	double avgTemp = 0.0;		
     e5c:	19 86       	std	Y+9, r1	; 0x09
     e5e:	1a 86       	std	Y+10, r1	; 0x0a
     e60:	1b 86       	std	Y+11, r1	; 0x0b
     e62:	1c 86       	std	Y+12, r1	; 0x0c

void holdAtTemp(uint16_t targetTemp, uint16_t targetTime){
	printStr("In hold at temp \n"); //send 
	
	double readTemp;
	double temp = 0;
     e64:	10 e0       	ldi	r17, 0x00	; 0
     e66:	e1 2c       	mov	r14, r1
     e68:	f1 2c       	mov	r15, r1
     e6a:	00 e0       	ldi	r16, 0x00	; 0
		readTemp = convertADC(adc_read());
		
		_delay_ms(1);// don't forget about the delay in the adc_read function!
		
		// if within range, below target temp power heater
		if(readTemp < (targetTemp-0.5)){
     e6c:	c3 01       	movw	r24, r6
     e6e:	a0 e0       	ldi	r26, 0x00	; 0
     e70:	b0 e0       	ldi	r27, 0x00	; 0
     e72:	8d 83       	std	Y+5, r24	; 0x05
     e74:	9e 83       	std	Y+6, r25	; 0x06
     e76:	af 83       	std	Y+7, r26	; 0x07
     e78:	b8 87       	std	Y+8, r27	; 0x08
     e7a:	c3 01       	movw	r24, r6
     e7c:	32 01       	movw	r6, r4
     e7e:	ee 86       	std	Y+14, r14	; 0x0e
     e80:	fd 86       	std	Y+13, r15	; 0x0d
     e82:	2c 01       	movw	r4, r24
	int numTemps = 0;
	
	count_ms = 0;
	printFlag = 0;
		
	while(count_ms < 2*targetTime){//count increments at half seconds
     e84:	22 c1       	rjmp	.+580    	; 0x10ca <holdAtTemp+0x2c6>
			
		readTemp = convertADC(adc_read());
     e86:	0e 94 83 00 	call	0x106	; 0x106 <adc_read>
     e8a:	bc 01       	movw	r22, r24
     e8c:	80 e0       	ldi	r24, 0x00	; 0
     e8e:	90 e0       	ldi	r25, 0x00	; 0
     e90:	0e 94 d8 0c 	call	0x19b0	; 0x19b0 <__floatunsisf>
     e94:	0e 94 9f 06 	call	0xd3e	; 0xd3e <convertADC>
     e98:	6b 01       	movw	r12, r22
     e9a:	7c 01       	movw	r14, r24
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
     e9c:	af e9       	ldi	r26, 0x9F	; 159
     e9e:	bf e0       	ldi	r27, 0x0F	; 15
     ea0:	11 97       	sbiw	r26, 0x01	; 1
     ea2:	f1 f7       	brne	.-4      	; 0xea0 <holdAtTemp+0x9c>
     ea4:	00 c0       	rjmp	.+0      	; 0xea6 <holdAtTemp+0xa2>
     ea6:	00 00       	nop
		
		_delay_ms(1);// don't forget about the delay in the adc_read function!
		
		// if within range, below target temp power heater
		if(readTemp < (targetTemp-0.5)){
     ea8:	6d 81       	ldd	r22, Y+5	; 0x05
     eaa:	7e 81       	ldd	r23, Y+6	; 0x06
     eac:	8f 81       	ldd	r24, Y+7	; 0x07
     eae:	98 85       	ldd	r25, Y+8	; 0x08
     eb0:	0e 94 d8 0c 	call	0x19b0	; 0x19b0 <__floatunsisf>
     eb4:	4b 01       	movw	r8, r22
     eb6:	5c 01       	movw	r10, r24
     eb8:	20 e0       	ldi	r18, 0x00	; 0
     eba:	30 e0       	ldi	r19, 0x00	; 0
     ebc:	40 e0       	ldi	r20, 0x00	; 0
     ebe:	5f e3       	ldi	r21, 0x3F	; 63
     ec0:	0e 94 be 0b 	call	0x177c	; 0x177c <__subsf3>
     ec4:	9b 01       	movw	r18, r22
     ec6:	ac 01       	movw	r20, r24
     ec8:	c7 01       	movw	r24, r14
     eca:	b6 01       	movw	r22, r12
     ecc:	0e 94 2b 0c 	call	0x1856	; 0x1856 <__cmpsf2>
     ed0:	88 23       	and	r24, r24
     ed2:	64 f5       	brge	.+88     	; 0xf2c <holdAtTemp+0x128>
			//OCR0A = 255 - (255/95)*targetTemp;
			OCR0A = NORM_PWM;
     ed4:	a7 01       	movw	r20, r14
     ed6:	96 01       	movw	r18, r12
     ed8:	c5 01       	movw	r24, r10
     eda:	b4 01       	movw	r22, r8
     edc:	0e 94 be 0b 	call	0x177c	; 0x177c <__subsf3>
     ee0:	69 83       	std	Y+1, r22	; 0x01
     ee2:	7a 83       	std	Y+2, r23	; 0x02
     ee4:	8b 83       	std	Y+3, r24	; 0x03
     ee6:	9c 83       	std	Y+4, r25	; 0x04
     ee8:	9b 01       	movw	r18, r22
     eea:	ac 01       	movw	r20, r24
     eec:	60 e0       	ldi	r22, 0x00	; 0
     eee:	70 e0       	ldi	r23, 0x00	; 0
     ef0:	80 e2       	ldi	r24, 0x20	; 32
     ef2:	93 e4       	ldi	r25, 0x43	; 67
     ef4:	0e 94 be 0b 	call	0x177c	; 0x177c <__subsf3>
     ef8:	0e 94 a9 0c 	call	0x1952	; 0x1952 <__fixunssfsi>
     efc:	67 bd       	out	0x27, r22	; 39
			PORTB = Fan_OFF;
     efe:	85 b1       	in	r24, 0x05	; 5
     f00:	87 7f       	andi	r24, 0xF7	; 247
     f02:	85 b9       	out	0x05, r24	; 5
     f04:	85 b9       	out	0x05, r24	; 5
			
			if (targetTemp > 85){
     f06:	b6 e5       	ldi	r27, 0x56	; 86
     f08:	4b 16       	cp	r4, r27
     f0a:	51 04       	cpc	r5, r1
     f0c:	08 f4       	brcc	.+2      	; 0xf10 <holdAtTemp+0x10c>
     f0e:	43 c0       	rjmp	.+134    	; 0xf96 <holdAtTemp+0x192>
				OCR0A = HIGH_PWM;
     f10:	29 81       	ldd	r18, Y+1	; 0x01
     f12:	3a 81       	ldd	r19, Y+2	; 0x02
     f14:	4b 81       	ldd	r20, Y+3	; 0x03
     f16:	5c 81       	ldd	r21, Y+4	; 0x04
     f18:	60 e0       	ldi	r22, 0x00	; 0
     f1a:	70 e0       	ldi	r23, 0x00	; 0
     f1c:	80 e0       	ldi	r24, 0x00	; 0
     f1e:	93 e4       	ldi	r25, 0x43	; 67
     f20:	0e 94 be 0b 	call	0x177c	; 0x177c <__subsf3>
     f24:	0e 94 a9 0c 	call	0x1952	; 0x1952 <__fixunssfsi>
     f28:	67 bd       	out	0x27, r22	; 39
     f2a:	35 c0       	rjmp	.+106    	; 0xf96 <holdAtTemp+0x192>
			}
		}			
		// within range but above temp, activate fan
		else if (readTemp > targetTemp+0.5){
     f2c:	20 e0       	ldi	r18, 0x00	; 0
     f2e:	30 e0       	ldi	r19, 0x00	; 0
     f30:	40 e0       	ldi	r20, 0x00	; 0
     f32:	5f e3       	ldi	r21, 0x3F	; 63
     f34:	c5 01       	movw	r24, r10
     f36:	b4 01       	movw	r22, r8
     f38:	0e 94 bf 0b 	call	0x177e	; 0x177e <__addsf3>
     f3c:	9b 01       	movw	r18, r22
     f3e:	ac 01       	movw	r20, r24
     f40:	c7 01       	movw	r24, r14
     f42:	b6 01       	movw	r22, r12
     f44:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <__gesf2>
     f48:	18 16       	cp	r1, r24
     f4a:	9c f4       	brge	.+38     	; 0xf72 <holdAtTemp+0x16e>
			OCR0A = HEAT_OFF;
     f4c:	ef ef       	ldi	r30, 0xFF	; 255
     f4e:	e7 bd       	out	0x27, r30	; 39
			PORTB = Fan_ON;
     f50:	85 b1       	in	r24, 0x05	; 5
     f52:	88 60       	ori	r24, 0x08	; 8
     f54:	85 b9       	out	0x05, r24	; 5
     f56:	85 b9       	out	0x05, r24	; 5
			
			if (readTemp > 90){
     f58:	20 e0       	ldi	r18, 0x00	; 0
     f5a:	30 e0       	ldi	r19, 0x00	; 0
     f5c:	44 eb       	ldi	r20, 0xB4	; 180
     f5e:	52 e4       	ldi	r21, 0x42	; 66
     f60:	c7 01       	movw	r24, r14
     f62:	b6 01       	movw	r22, r12
     f64:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <__gesf2>
     f68:	18 16       	cp	r1, r24
     f6a:	ac f4       	brge	.+42     	; 0xf96 <holdAtTemp+0x192>
				OCR0A = HEAT_SOFF;
     f6c:	f0 ef       	ldi	r31, 0xF0	; 240
     f6e:	f7 bd       	out	0x27, r31	; 39
     f70:	12 c0       	rjmp	.+36     	; 0xf96 <holdAtTemp+0x192>
			}
		}
		else{ // otherwise, in range, turn off fan and apply idle heating
			PORTB = Fan_OFF;
     f72:	85 b1       	in	r24, 0x05	; 5
     f74:	87 7f       	andi	r24, 0xF7	; 247
     f76:	85 b9       	out	0x05, r24	; 5
     f78:	85 b9       	out	0x05, r24	; 5
			OCR0A = NORM_IDLE;
     f7a:	80 ec       	ldi	r24, 0xC0	; 192
     f7c:	87 bd       	out	0x27, r24	; 39
			
			if (targetTemp > 85){
     f7e:	96 e5       	ldi	r25, 0x56	; 86
     f80:	49 16       	cp	r4, r25
     f82:	51 04       	cpc	r5, r1
     f84:	10 f0       	brcs	.+4      	; 0xf8a <holdAtTemp+0x186>
				OCR0A = HIGH_IDLE;
     f86:	a8 e7       	ldi	r26, 0x78	; 120
     f88:	a7 bd       	out	0x27, r26	; 39
			}
			
			if (targetTemp < 60){
     f8a:	bc e3       	ldi	r27, 0x3C	; 60
     f8c:	4b 16       	cp	r4, r27
     f8e:	51 04       	cpc	r5, r1
     f90:	10 f4       	brcc	.+4      	; 0xf96 <holdAtTemp+0x192>
				OCR0A = HEAT_OFF;
     f92:	ef ef       	ldi	r30, 0xFF	; 255
     f94:	e7 bd       	out	0x27, r30	; 39
				//PORTB = Fan_OFF;
			//}
		//}
		
				
		if (timerFlag == 0){	// timer flag is true every 1/2 second
     f96:	80 91 90 02 	lds	r24, 0x0290
     f9a:	90 91 91 02 	lds	r25, 0x0291
     f9e:	89 2b       	or	r24, r25
     fa0:	79 f4       	brne	.+30     	; 0xfc0 <holdAtTemp+0x1bc>
			temp += readTemp;	// sums gathered temperatures
     fa2:	a7 01       	movw	r20, r14
     fa4:	96 01       	movw	r18, r12
     fa6:	61 2f       	mov	r22, r17
     fa8:	7e 85       	ldd	r23, Y+14	; 0x0e
     faa:	8d 85       	ldd	r24, Y+13	; 0x0d
     fac:	90 2f       	mov	r25, r16
     fae:	0e 94 bf 0b 	call	0x177e	; 0x177e <__addsf3>
     fb2:	16 2f       	mov	r17, r22
     fb4:	7e 87       	std	Y+14, r23	; 0x0e
     fb6:	8d 87       	std	Y+13, r24	; 0x0d
     fb8:	09 2f       	mov	r16, r25
			numTemps++;			// keep track of the number of temperatures gathered
     fba:	ff ef       	ldi	r31, 0xFF	; 255
     fbc:	2f 1a       	sub	r2, r31
     fbe:	3f 0a       	sbc	r3, r31
			//timerFlag = 0;		// reset the 1/4 second timer flag
		}
		
		if (timerFlag == 1){
     fc0:	80 91 90 02 	lds	r24, 0x0290
     fc4:	90 91 91 02 	lds	r25, 0x0291
     fc8:	01 97       	sbiw	r24, 0x01	; 1
     fca:	09 f0       	breq	.+2      	; 0xfce <holdAtTemp+0x1ca>
     fcc:	5d c0       	rjmp	.+186    	; 0x1088 <holdAtTemp+0x284>
			avgTemp = temp / numTemps;	// average the gathered temperature readings
     fce:	b1 01       	movw	r22, r2
     fd0:	33 0c       	add	r3, r3
     fd2:	88 0b       	sbc	r24, r24
     fd4:	99 0b       	sbc	r25, r25
     fd6:	0e 94 da 0c 	call	0x19b4	; 0x19b4 <__floatsisf>
     fda:	9b 01       	movw	r18, r22
     fdc:	ac 01       	movw	r20, r24
     fde:	61 2f       	mov	r22, r17
     fe0:	7e 85       	ldd	r23, Y+14	; 0x0e
     fe2:	8d 85       	ldd	r24, Y+13	; 0x0d
     fe4:	90 2f       	mov	r25, r16
     fe6:	0e 94 30 0c 	call	0x1860	; 0x1860 <__divsf3>
     fea:	69 87       	std	Y+9, r22	; 0x09
     fec:	7a 87       	std	Y+10, r23	; 0x0a
     fee:	8b 87       	std	Y+11, r24	; 0x0b
     ff0:	9c 87       	std	Y+12, r25	; 0x0c
			temp = 0;					// reset the summed temperatures
			numTemps = 0;				// reset the number of gathered temperatures
			timerFlag = 0;
     ff2:	10 92 91 02 	sts	0x0291, r1
     ff6:	10 92 90 02 	sts	0x0290, r1
			
			if (((avgTemp*10)/10 >= targetTemp+1.5) || ((avgTemp*10)/10 <= targetTemp-1.5)){ // if current temperature is outside of +/- 1.5C range
     ffa:	20 e0       	ldi	r18, 0x00	; 0
     ffc:	30 e0       	ldi	r19, 0x00	; 0
     ffe:	40 e2       	ldi	r20, 0x20	; 32
    1000:	51 e4       	ldi	r21, 0x41	; 65
    1002:	0e 94 8f 0d 	call	0x1b1e	; 0x1b1e <__mulsf3>
    1006:	20 e0       	ldi	r18, 0x00	; 0
    1008:	30 e0       	ldi	r19, 0x00	; 0
    100a:	40 e2       	ldi	r20, 0x20	; 32
    100c:	51 e4       	ldi	r21, 0x41	; 65
    100e:	0e 94 30 0c 	call	0x1860	; 0x1860 <__divsf3>
    1012:	6b 01       	movw	r12, r22
    1014:	7c 01       	movw	r14, r24
    1016:	20 e0       	ldi	r18, 0x00	; 0
    1018:	30 e0       	ldi	r19, 0x00	; 0
    101a:	40 ec       	ldi	r20, 0xC0	; 192
    101c:	5f e3       	ldi	r21, 0x3F	; 63
    101e:	c5 01       	movw	r24, r10
    1020:	b4 01       	movw	r22, r8
    1022:	0e 94 bf 0b 	call	0x177e	; 0x177e <__addsf3>
    1026:	9b 01       	movw	r18, r22
    1028:	ac 01       	movw	r20, r24
    102a:	c7 01       	movw	r24, r14
    102c:	b6 01       	movw	r22, r12
    102e:	0e 94 8a 0d 	call	0x1b14	; 0x1b14 <__gesf2>
    1032:	88 23       	and	r24, r24
    1034:	84 f4       	brge	.+32     	; 0x1056 <holdAtTemp+0x252>
    1036:	20 e0       	ldi	r18, 0x00	; 0
    1038:	30 e0       	ldi	r19, 0x00	; 0
    103a:	40 ec       	ldi	r20, 0xC0	; 192
    103c:	5f e3       	ldi	r21, 0x3F	; 63
    103e:	c5 01       	movw	r24, r10
    1040:	b4 01       	movw	r22, r8
    1042:	0e 94 be 0b 	call	0x177c	; 0x177c <__subsf3>
    1046:	9b 01       	movw	r18, r22
    1048:	ac 01       	movw	r20, r24
    104a:	c7 01       	movw	r24, r14
    104c:	b6 01       	movw	r22, r12
    104e:	0e 94 2b 0c 	call	0x1856	; 0x1856 <__cmpsf2>
    1052:	18 16       	cp	r1, r24
    1054:	7c f0       	brlt	.+30     	; 0x1074 <holdAtTemp+0x270>
				count_ms = 0; //reset counter if temp is outside of +/- 1.5C range
    1056:	10 92 93 02 	sts	0x0293, r1
    105a:	10 92 92 02 	sts	0x0292, r1
				PORTD = LED_OFF;
    105e:	8b b1       	in	r24, 0x0b	; 11
    1060:	8f 7b       	andi	r24, 0xBF	; 191
    1062:	8b b9       	out	0x0b, r24	; 11
    1064:	8b b9       	out	0x0b, r24	; 11
		}
		
		if (timerFlag == 1){
			avgTemp = temp / numTemps;	// average the gathered temperature readings
			temp = 0;					// reset the summed temperatures
			numTemps = 0;				// reset the number of gathered temperatures
    1066:	21 2c       	mov	r2, r1
    1068:	31 2c       	mov	r3, r1
			//timerFlag = 0;		// reset the 1/4 second timer flag
		}
		
		if (timerFlag == 1){
			avgTemp = temp / numTemps;	// average the gathered temperature readings
			temp = 0;					// reset the summed temperatures
    106a:	10 e0       	ldi	r17, 0x00	; 0
    106c:	1e 86       	std	Y+14, r1	; 0x0e
    106e:	1d 86       	std	Y+13, r1	; 0x0d
    1070:	00 e0       	ldi	r16, 0x00	; 0
			numTemps = 0;				// reset the number of gathered temperatures
			timerFlag = 0;
			
			if (((avgTemp*10)/10 >= targetTemp+1.5) || ((avgTemp*10)/10 <= targetTemp-1.5)){ // if current temperature is outside of +/- 1.5C range
				count_ms = 0; //reset counter if temp is outside of +/- 1.5C range
				PORTD = LED_OFF;
    1072:	0a c0       	rjmp	.+20     	; 0x1088 <holdAtTemp+0x284>
			}
			else{
				PORTD = LED_ON;
    1074:	8b b1       	in	r24, 0x0b	; 11
    1076:	80 64       	ori	r24, 0x40	; 64
    1078:	8b b9       	out	0x0b, r24	; 11
    107a:	8b b9       	out	0x0b, r24	; 11
		}
		
		if (timerFlag == 1){
			avgTemp = temp / numTemps;	// average the gathered temperature readings
			temp = 0;					// reset the summed temperatures
			numTemps = 0;				// reset the number of gathered temperatures
    107c:	21 2c       	mov	r2, r1
    107e:	31 2c       	mov	r3, r1
			//timerFlag = 0;		// reset the 1/4 second timer flag
		}
		
		if (timerFlag == 1){
			avgTemp = temp / numTemps;	// average the gathered temperature readings
			temp = 0;					// reset the summed temperatures
    1080:	10 e0       	ldi	r17, 0x00	; 0
    1082:	1e 86       	std	Y+14, r1	; 0x0e
    1084:	1d 86       	std	Y+13, r1	; 0x0d
    1086:	00 e0       	ldi	r16, 0x00	; 0
			
			
				
		}
		
		if (printFlag == 4){
    1088:	80 91 8e 02 	lds	r24, 0x028E
    108c:	90 91 8f 02 	lds	r25, 0x028F
    1090:	04 97       	sbiw	r24, 0x04	; 4
    1092:	d9 f4       	brne	.+54     	; 0x10ca <holdAtTemp+0x2c6>
			printStr("Temp is ");
    1094:	82 e1       	ldi	r24, 0x12	; 18
    1096:	91 e0       	ldi	r25, 0x01	; 1
    1098:	0e 94 7f 0b 	call	0x16fe	; 0x16fe <printStr>
			int_to_char(avgTemp);
    109c:	69 85       	ldd	r22, Y+9	; 0x09
    109e:	7a 85       	ldd	r23, Y+10	; 0x0a
    10a0:	8b 85       	ldd	r24, Y+11	; 0x0b
    10a2:	9c 85       	ldd	r25, Y+12	; 0x0c
    10a4:	0e 94 a2 0c 	call	0x1944	; 0x1944 <__fixsfsi>
    10a8:	cb 01       	movw	r24, r22
    10aa:	0e 94 95 0b 	call	0x172a	; 0x172a <int_to_char>
						
			printStr(" and Target temp is ");
    10ae:	8b e1       	ldi	r24, 0x1B	; 27
    10b0:	91 e0       	ldi	r25, 0x01	; 1
    10b2:	0e 94 7f 0b 	call	0x16fe	; 0x16fe <printStr>
			int_to_char(targetTemp);
    10b6:	c2 01       	movw	r24, r4
    10b8:	0e 94 95 0b 	call	0x172a	; 0x172a <int_to_char>
			uart_putchar('\n');
    10bc:	8a e0       	ldi	r24, 0x0A	; 10
    10be:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <uart_putchar>
			printFlag = 0;
    10c2:	10 92 8f 02 	sts	0x028F, r1
    10c6:	10 92 8e 02 	sts	0x028E, r1
	int numTemps = 0;
	
	count_ms = 0;
	printFlag = 0;
		
	while(count_ms < 2*targetTime){//count increments at half seconds
    10ca:	80 91 92 02 	lds	r24, 0x0292
    10ce:	90 91 93 02 	lds	r25, 0x0293
    10d2:	86 15       	cp	r24, r6
    10d4:	97 05       	cpc	r25, r7
    10d6:	08 f4       	brcc	.+2      	; 0x10da <holdAtTemp+0x2d6>
    10d8:	d6 ce       	rjmp	.-596    	; 0xe86 <holdAtTemp+0x82>
		//isBatLow();
							
		
	}		
	
	OCR0A = HEAT_OFF;		// set heater to 0% duty cycle
    10da:	8f ef       	ldi	r24, 0xFF	; 255
    10dc:	87 bd       	out	0x27, r24	; 39
	PORTB = Fan_OFF;	// power off the fan
    10de:	85 b1       	in	r24, 0x05	; 5
    10e0:	87 7f       	andi	r24, 0xF7	; 247
    10e2:	85 b9       	out	0x05, r24	; 5
    10e4:	85 b9       	out	0x05, r24	; 5
		
		
}			
    10e6:	2e 96       	adiw	r28, 0x0e	; 14
    10e8:	0f b6       	in	r0, 0x3f	; 63
    10ea:	f8 94       	cli
    10ec:	de bf       	out	0x3e, r29	; 62
    10ee:	0f be       	out	0x3f, r0	; 63
    10f0:	cd bf       	out	0x3d, r28	; 61
    10f2:	df 91       	pop	r29
    10f4:	cf 91       	pop	r28
    10f6:	1f 91       	pop	r17
    10f8:	0f 91       	pop	r16
    10fa:	ff 90       	pop	r15
    10fc:	ef 90       	pop	r14
    10fe:	df 90       	pop	r13
    1100:	cf 90       	pop	r12
    1102:	bf 90       	pop	r11
    1104:	af 90       	pop	r10
    1106:	9f 90       	pop	r9
    1108:	8f 90       	pop	r8
    110a:	7f 90       	pop	r7
    110c:	6f 90       	pop	r6
    110e:	5f 90       	pop	r5
    1110:	4f 90       	pop	r4
    1112:	3f 90       	pop	r3
    1114:	2f 90       	pop	r2
    1116:	08 95       	ret

00001118 <ValidateData>:


void ValidateData(void){
    1118:	ef 92       	push	r14
    111a:	ff 92       	push	r15
    111c:	0f 93       	push	r16
    111e:	1f 93       	push	r17
    1120:	cf 93       	push	r28
    1122:	df 93       	push	r29
    1124:	08 e9       	ldi	r16, 0x98	; 152
    1126:	12 e0       	ldi	r17, 0x02	; 2
    1128:	26 eb       	ldi	r18, 0xB6	; 182
    112a:	32 e0       	ldi	r19, 0x02	; 2
    112c:	f8 01       	movw	r30, r16
	int i;
	int j;
	// Zero fill temp/time buffer:
	for (i =0; i<30; i++)
	{
		passData[i]='0';
    112e:	80 e3       	ldi	r24, 0x30	; 48
    1130:	81 93       	st	Z+, r24
	char newLine = '*';
	int valid = 0;			// Control Variable
	int i;
	int j;
	// Zero fill temp/time buffer:
	for (i =0; i<30; i++)
    1132:	e2 17       	cp	r30, r18
    1134:	f3 07       	cpc	r31, r19
    1136:	e1 f7       	brne	.-8      	; 0x1130 <ValidateData+0x18>
	i=0;
	char istrue ='Y';	// Hard coding handshake to validate data ***for testing***
	
	
	// For testing:
	printStr("Entered Validate Data Function \n"); // Debugg statement ***for testing***
    1138:	80 e3       	ldi	r24, 0x30	; 48
    113a:	91 e0       	ldi	r25, 0x01	; 1
    113c:	0e 94 7f 0b 	call	0x16fe	; 0x16fe <printStr>
    1140:	2f ef       	ldi	r18, 0xFF	; 255
    1142:	87 ea       	ldi	r24, 0xA7	; 167
    1144:	91 e6       	ldi	r25, 0x61	; 97
    1146:	21 50       	subi	r18, 0x01	; 1
    1148:	80 40       	sbci	r24, 0x00	; 0
    114a:	90 40       	sbci	r25, 0x00	; 0
    114c:	e1 f7       	brne	.-8      	; 0x1146 <ValidateData+0x2e>
    114e:	00 c0       	rjmp	.+0      	; 0x1150 <ValidateData+0x38>
    1150:	00 00       	nop
	_delay_ms(2000);
	
	while(valid == 0){				// Control Structure for validating data values:
		printStr("Input is \n");	// Debugg statement ***for testing***
    1152:	81 e5       	ldi	r24, 0x51	; 81
    1154:	91 e0       	ldi	r25, 0x01	; 1
    1156:	0e 94 7f 0b 	call	0x16fe	; 0x16fe <printStr>
    115a:	0f 2e       	mov	r0, r31
    115c:	f8 e9       	ldi	r31, 0x98	; 152
    115e:	ef 2e       	mov	r14, r31
    1160:	f2 e0       	ldi	r31, 0x02	; 2
    1162:	ff 2e       	mov	r15, r31
    1164:	f0 2d       	mov	r31, r0
		//_delay_ms(2000);
		
		while (getValue != newLine)		// Takes in all 18 values send and confirms that the values are correct:
		{
			getValue = uart_getchar();	// Receive 6 values with 3 char per value.
    1166:	0e 94 72 0b 	call	0x16e4	; 0x16e4 <uart_getchar>
    116a:	c8 2f       	mov	r28, r24
			uart_putchar(getValue);		// Transmit them back to the App.
    116c:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <uart_putchar>
			passData[i] = getValue;		// Put value into array.
    1170:	f7 01       	movw	r30, r14
    1172:	c1 93       	st	Z+, r28
    1174:	7f 01       	movw	r14, r30
	
	while(valid == 0){				// Control Structure for validating data values:
		printStr("Input is \n");	// Debugg statement ***for testing***
		//_delay_ms(2000);
		
		while (getValue != newLine)		// Takes in all 18 values send and confirms that the values are correct:
    1176:	ca 32       	cpi	r28, 0x2A	; 42
    1178:	b1 f7       	brne	.-20     	; 0x1166 <ValidateData+0x4e>
			getValue = uart_getchar();	// Receive 6 values with 3 char per value.
			uart_putchar(getValue);		// Transmit them back to the App.
			passData[i] = getValue;		// Put value into array.
			i++;						// Shift array.
		}
		uart_putchar('\n');				// After all the char are send needs a delimiter.
    117a:	8a e0       	ldi	r24, 0x0A	; 10
    117c:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <uart_putchar>
    1180:	ff ef       	ldi	r31, 0xFF	; 255
    1182:	23 e2       	ldi	r18, 0x23	; 35
    1184:	84 ef       	ldi	r24, 0xF4	; 244
    1186:	f1 50       	subi	r31, 0x01	; 1
    1188:	20 40       	sbci	r18, 0x00	; 0
    118a:	80 40       	sbci	r24, 0x00	; 0
    118c:	e1 f7       	brne	.-8      	; 0x1186 <ValidateData+0x6e>
    118e:	00 c0       	rjmp	.+0      	; 0x1190 <ValidateData+0x78>
    1190:	00 00       	nop
		
		uart_putchar('\n');				// After all the char are send needs a delimiter.
		_delay_ms(5000);
		*/
		
		printStr("Array is? \n"); // Debugg statement ***for testing***
    1192:	8c e5       	ldi	r24, 0x5C	; 92
    1194:	91 e0       	ldi	r25, 0x01	; 1
    1196:	0e 94 7f 0b 	call	0x16fe	; 0x16fe <printStr>
    119a:	9f ef       	ldi	r25, 0xFF	; 255
    119c:	e7 ea       	ldi	r30, 0xA7	; 167
    119e:	f1 e6       	ldi	r31, 0x61	; 97
    11a0:	91 50       	subi	r25, 0x01	; 1
    11a2:	e0 40       	sbci	r30, 0x00	; 0
    11a4:	f0 40       	sbci	r31, 0x00	; 0
    11a6:	e1 f7       	brne	.-8      	; 0x11a0 <ValidateData+0x88>
    11a8:	00 c0       	rjmp	.+0      	; 0x11aa <ValidateData+0x92>
    11aa:	00 00       	nop
    11ac:	c0 eb       	ldi	r28, 0xB0	; 176
    11ae:	d2 e0       	ldi	r29, 0x02	; 2
		_delay_ms(2000);
		
		// Validating that data in array is same as what was passed. Debugg statements ***for testing***
		for (j=0; j<24; j++)	// 18 for no pre-heat & 24 for with pre-heat
		{
			uart_putchar(passData[j]);	
    11b0:	f8 01       	movw	r30, r16
    11b2:	81 91       	ld	r24, Z+
    11b4:	8f 01       	movw	r16, r30
    11b6:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <uart_putchar>
		
		printStr("Array is? \n"); // Debugg statement ***for testing***
		_delay_ms(2000);
		
		// Validating that data in array is same as what was passed. Debugg statements ***for testing***
		for (j=0; j<24; j++)	// 18 for no pre-heat & 24 for with pre-heat
    11ba:	0c 17       	cp	r16, r28
    11bc:	1d 07       	cpc	r17, r29
    11be:	c1 f7       	brne	.-16     	; 0x11b0 <ValidateData+0x98>
		{
			uart_putchar(passData[j]);	
		}
		uart_putchar('\n');				// After all the char are send needs a delimiter.
    11c0:	8a e0       	ldi	r24, 0x0A	; 10
    11c2:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <uart_putchar>
    11c6:	ff ef       	ldi	r31, 0xFF	; 255
    11c8:	23 e2       	ldi	r18, 0x23	; 35
    11ca:	84 ef       	ldi	r24, 0xF4	; 244
    11cc:	f1 50       	subi	r31, 0x01	; 1
    11ce:	20 40       	sbci	r18, 0x00	; 0
    11d0:	80 40       	sbci	r24, 0x00	; 0
    11d2:	e1 f7       	brne	.-8      	; 0x11cc <ValidateData+0xb4>
    11d4:	00 c0       	rjmp	.+0      	; 0x11d6 <ValidateData+0xbe>
    11d6:	00 00       	nop
		if (getValue == istrue)			// Check with app if values were valid.
		{
			valid = 1;					// Exit value for control structure.
		}
	}
}
    11d8:	df 91       	pop	r29
    11da:	cf 91       	pop	r28
    11dc:	1f 91       	pop	r17
    11de:	0f 91       	pop	r16
    11e0:	ff 90       	pop	r15
    11e2:	ef 90       	pop	r14
    11e4:	08 95       	ret

000011e6 <set_PCR>:

void set_PCR(void){
    11e6:	ef 92       	push	r14
    11e8:	ff 92       	push	r15
    11ea:	0f 93       	push	r16
    11ec:	1f 93       	push	r17
    11ee:	cf 93       	push	r28
    11f0:	df 93       	push	r29
	// Control Variable
	int hundreds;
	int tens;
	int ones;
	
	printStr("In set array is \n"); //send
    11f2:	88 e6       	ldi	r24, 0x68	; 104
    11f4:	91 e0       	ldi	r25, 0x01	; 1
    11f6:	0e 94 7f 0b 	call	0x16fe	; 0x16fe <printStr>
    11fa:	2f ef       	ldi	r18, 0xFF	; 255
    11fc:	8b e7       	ldi	r24, 0x7B	; 123
    11fe:	92 e9       	ldi	r25, 0x92	; 146
    1200:	21 50       	subi	r18, 0x01	; 1
    1202:	80 40       	sbci	r24, 0x00	; 0
    1204:	90 40       	sbci	r25, 0x00	; 0
    1206:	e1 f7       	brne	.-8      	; 0x1200 <set_PCR+0x1a>
    1208:	00 c0       	rjmp	.+0      	; 0x120a <set_PCR+0x24>
    120a:	00 00       	nop
    120c:	c8 e9       	ldi	r28, 0x98	; 152
    120e:	d2 e0       	ldi	r29, 0x02	; 2
    1210:	00 eb       	ldi	r16, 0xB0	; 176
    1212:	12 e0       	ldi	r17, 0x02	; 2
	_delay_ms(3000);				// Pause for app to check
	for (int j=0; j<24; j++) // 18 for no pre-heat & 25 for with pre-heat
	{
		uart_putchar(passData[j]);
    1214:	89 91       	ld	r24, Y+
    1216:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <uart_putchar>
	int tens;
	int ones;
	
	printStr("In set array is \n"); //send
	_delay_ms(3000);				// Pause for app to check
	for (int j=0; j<24; j++) // 18 for no pre-heat & 25 for with pre-heat
    121a:	c0 17       	cp	r28, r16
    121c:	d1 07       	cpc	r29, r17
    121e:	d1 f7       	brne	.-12     	; 0x1214 <set_PCR+0x2e>
	{
		uart_putchar(passData[j]);
	}
	uart_putchar('\n');				// After all the char are send needs a delimiter.
    1220:	8a e0       	ldi	r24, 0x0A	; 10
    1222:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <uart_putchar>
    1226:	2f ef       	ldi	r18, 0xFF	; 255
    1228:	87 ea       	ldi	r24, 0xA7	; 167
    122a:	91 e6       	ldi	r25, 0x61	; 97
    122c:	21 50       	subi	r18, 0x01	; 1
    122e:	80 40       	sbci	r24, 0x00	; 0
    1230:	90 40       	sbci	r25, 0x00	; 0
    1232:	e1 f7       	brne	.-8      	; 0x122c <set_PCR+0x46>
    1234:	00 c0       	rjmp	.+0      	; 0x1236 <set_PCR+0x50>
    1236:	00 00       	nop
	_delay_ms(2000);				// Pause for app to check
	
	///* Function with Pre-heat option:
	// Set Preheat Temperature:
	hundreds = passData[0];
    1238:	c8 e9       	ldi	r28, 0x98	; 152
    123a:	d2 e0       	ldi	r29, 0x02	; 2
    123c:	e8 80       	ld	r14, Y
	tens = passData[1];
    123e:	f9 80       	ldd	r15, Y+1	; 0x01
	ones = passData[2];
    1240:	0a 81       	ldd	r16, Y+2	; 0x02
	hundreds = hundreds - '0';
    1242:	80 ed       	ldi	r24, 0xD0	; 208
    1244:	8e 0d       	add	r24, r14
	tens= tens - '0';
	ones = ones - '0';
	
	preheatTemp = hundreds * 100 + tens * 10 + ones;	// Shifts hundreds place value into time variable.
    1246:	14 e6       	ldi	r17, 0x64	; 100
	// Set Preheat Temperature:
	hundreds = passData[0];
	tens = passData[1];
	ones = passData[2];
	hundreds = hundreds - '0';
	tens= tens - '0';
    1248:	9f 2d       	mov	r25, r15
    124a:	99 0f       	add	r25, r25
	ones = ones - '0';
	
	preheatTemp = hundreds * 100 + tens * 10 + ones;	// Shifts hundreds place value into time variable.
    124c:	90 56       	subi	r25, 0x60	; 96
    124e:	29 2f       	mov	r18, r25
    1250:	22 0f       	add	r18, r18
    1252:	22 0f       	add	r18, r18
    1254:	92 0f       	add	r25, r18
    1256:	81 9f       	mul	r24, r17
    1258:	90 0d       	add	r25, r0
    125a:	11 24       	eor	r1, r1
	hundreds = passData[0];
	tens = passData[1];
	ones = passData[2];
	hundreds = hundreds - '0';
	tens= tens - '0';
	ones = ones - '0';
    125c:	90 0f       	add	r25, r16
	
	preheatTemp = hundreds * 100 + tens * 10 + ones;	// Shifts hundreds place value into time variable.
    125e:	90 53       	subi	r25, 0x30	; 48
    1260:	90 93 b3 02 	sts	0x02B3, r25

	printStr("Preheat temp is "); //send App
    1264:	8a e7       	ldi	r24, 0x7A	; 122
    1266:	91 e0       	ldi	r25, 0x01	; 1
    1268:	0e 94 7f 0b 	call	0x16fe	; 0x16fe <printStr>
	hundreds = hundreds + '0';
	tens= tens + '0';
	ones = ones + '0';
	uart_putchar(hundreds);
    126c:	8e 2d       	mov	r24, r14
    126e:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <uart_putchar>
	uart_putchar(tens);
    1272:	8f 2d       	mov	r24, r15
    1274:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <uart_putchar>
	uart_putchar(ones);
    1278:	80 2f       	mov	r24, r16
    127a:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <uart_putchar>
	uart_putchar('\n');
    127e:	8a e0       	ldi	r24, 0x0A	; 10
    1280:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <uart_putchar>
    1284:	2f ef       	ldi	r18, 0xFF	; 255
    1286:	87 ea       	ldi	r24, 0xA7	; 167
    1288:	91 e6       	ldi	r25, 0x61	; 97
    128a:	21 50       	subi	r18, 0x01	; 1
    128c:	80 40       	sbci	r24, 0x00	; 0
    128e:	90 40       	sbci	r25, 0x00	; 0
    1290:	e1 f7       	brne	.-8      	; 0x128a <set_PCR+0xa4>
    1292:	00 c0       	rjmp	.+0      	; 0x1294 <set_PCR+0xae>
    1294:	00 00       	nop
	_delay_ms(2000);
	
	// Set Preheat Time:
	hundreds = passData[3];
    1296:	eb 80       	ldd	r14, Y+3	; 0x03
	tens = passData[4];
    1298:	fc 80       	ldd	r15, Y+4	; 0x04
	ones = passData[5];
    129a:	0d 81       	ldd	r16, Y+5	; 0x05
	hundreds = hundreds - '0';
    129c:	80 ed       	ldi	r24, 0xD0	; 208
    129e:	8e 0d       	add	r24, r14
	tens= tens - '0';
    12a0:	9f 2d       	mov	r25, r15
    12a2:	99 0f       	add	r25, r25
	ones = ones - '0';
	
	preheatTime = hundreds * 100 +tens * 10 + ones;	// Shifts hundreds place value into time variable.
    12a4:	90 56       	subi	r25, 0x60	; 96
    12a6:	29 2f       	mov	r18, r25
    12a8:	22 0f       	add	r18, r18
    12aa:	22 0f       	add	r18, r18
    12ac:	92 0f       	add	r25, r18
    12ae:	81 9f       	mul	r24, r17
    12b0:	90 0d       	add	r25, r0
    12b2:	11 24       	eor	r1, r1
	hundreds = passData[3];
	tens = passData[4];
	ones = passData[5];
	hundreds = hundreds - '0';
	tens= tens - '0';
	ones = ones - '0';
    12b4:	90 0f       	add	r25, r16
	
	preheatTime = hundreds * 100 +tens * 10 + ones;	// Shifts hundreds place value into time variable.
    12b6:	90 53       	subi	r25, 0x30	; 48
    12b8:	90 93 95 02 	sts	0x0295, r25

	printStr("Preheat time is "); //send App
    12bc:	8b e8       	ldi	r24, 0x8B	; 139
    12be:	91 e0       	ldi	r25, 0x01	; 1
    12c0:	0e 94 7f 0b 	call	0x16fe	; 0x16fe <printStr>
	hundreds = hundreds + '0';
	tens= tens + '0';
	ones = ones + '0';
	uart_putchar(hundreds);
    12c4:	8e 2d       	mov	r24, r14
    12c6:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <uart_putchar>
	uart_putchar(tens);
    12ca:	8f 2d       	mov	r24, r15
    12cc:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <uart_putchar>
	uart_putchar(ones);
    12d0:	80 2f       	mov	r24, r16
    12d2:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <uart_putchar>
	uart_putchar('\n');
    12d6:	8a e0       	ldi	r24, 0x0A	; 10
    12d8:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <uart_putchar>
    12dc:	2f ef       	ldi	r18, 0xFF	; 255
    12de:	87 ea       	ldi	r24, 0xA7	; 167
    12e0:	91 e6       	ldi	r25, 0x61	; 97
    12e2:	21 50       	subi	r18, 0x01	; 1
    12e4:	80 40       	sbci	r24, 0x00	; 0
    12e6:	90 40       	sbci	r25, 0x00	; 0
    12e8:	e1 f7       	brne	.-8      	; 0x12e2 <set_PCR+0xfc>
    12ea:	00 c0       	rjmp	.+0      	; 0x12ec <set_PCR+0x106>
    12ec:	00 00       	nop
	_delay_ms(2000);
	
	
	// Set Denaturation Temperature:
	hundreds = passData[6];
    12ee:	ee 80       	ldd	r14, Y+6	; 0x06
	tens = passData[7];
    12f0:	ff 80       	ldd	r15, Y+7	; 0x07
	ones = passData[8];
    12f2:	08 85       	ldd	r16, Y+8	; 0x08
	hundreds = hundreds - '0';
    12f4:	80 ed       	ldi	r24, 0xD0	; 208
    12f6:	8e 0d       	add	r24, r14
	tens= tens - '0';
    12f8:	9f 2d       	mov	r25, r15
    12fa:	99 0f       	add	r25, r25
	ones = ones - '0';
	
	denTemp = hundreds * 100 + tens * 10 + ones;	// Shifts hundreds place value into time variable.
    12fc:	90 56       	subi	r25, 0x60	; 96
    12fe:	29 2f       	mov	r18, r25
    1300:	22 0f       	add	r18, r18
    1302:	22 0f       	add	r18, r18
    1304:	92 0f       	add	r25, r18
    1306:	81 9f       	mul	r24, r17
    1308:	90 0d       	add	r25, r0
    130a:	11 24       	eor	r1, r1
	hundreds = passData[6];
	tens = passData[7];
	ones = passData[8];
	hundreds = hundreds - '0';
	tens= tens - '0';
	ones = ones - '0';
    130c:	90 0f       	add	r25, r16
	
	denTemp = hundreds * 100 + tens * 10 + ones;	// Shifts hundreds place value into time variable.
    130e:	90 53       	subi	r25, 0x30	; 48
    1310:	90 93 b2 02 	sts	0x02B2, r25
	
	printStr("Denaturing temp is "); //send App
    1314:	8c e9       	ldi	r24, 0x9C	; 156
    1316:	91 e0       	ldi	r25, 0x01	; 1
    1318:	0e 94 7f 0b 	call	0x16fe	; 0x16fe <printStr>
	hundreds = hundreds + '0';
	tens= tens + '0';
	ones = ones + '0';
	uart_putchar(hundreds);
    131c:	8e 2d       	mov	r24, r14
    131e:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <uart_putchar>
	uart_putchar(tens);
    1322:	8f 2d       	mov	r24, r15
    1324:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <uart_putchar>
	uart_putchar(ones);
    1328:	80 2f       	mov	r24, r16
    132a:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <uart_putchar>
	uart_putchar('\n');
    132e:	8a e0       	ldi	r24, 0x0A	; 10
    1330:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <uart_putchar>
    1334:	2f ef       	ldi	r18, 0xFF	; 255
    1336:	87 ea       	ldi	r24, 0xA7	; 167
    1338:	91 e6       	ldi	r25, 0x61	; 97
    133a:	21 50       	subi	r18, 0x01	; 1
    133c:	80 40       	sbci	r24, 0x00	; 0
    133e:	90 40       	sbci	r25, 0x00	; 0
    1340:	e1 f7       	brne	.-8      	; 0x133a <set_PCR+0x154>
    1342:	00 c0       	rjmp	.+0      	; 0x1344 <set_PCR+0x15e>
    1344:	00 00       	nop
	_delay_ms(2000);
	
	// Set Denaturation Time:
	hundreds = passData[9];
    1346:	e9 84       	ldd	r14, Y+9	; 0x09
	tens = passData[10];
    1348:	fa 84       	ldd	r15, Y+10	; 0x0a
	ones = passData[11];
    134a:	0b 85       	ldd	r16, Y+11	; 0x0b
	hundreds = hundreds - '0';
    134c:	80 ed       	ldi	r24, 0xD0	; 208
    134e:	8e 0d       	add	r24, r14
	tens= tens - '0';
    1350:	9f 2d       	mov	r25, r15
    1352:	99 0f       	add	r25, r25
	ones = ones - '0';
	
	denTime = hundreds * 100 +tens * 10 + ones;	// Shifts hundreds place value into time variable.
    1354:	90 56       	subi	r25, 0x60	; 96
    1356:	29 2f       	mov	r18, r25
    1358:	22 0f       	add	r18, r18
    135a:	22 0f       	add	r18, r18
    135c:	92 0f       	add	r25, r18
    135e:	81 9f       	mul	r24, r17
    1360:	90 0d       	add	r25, r0
    1362:	11 24       	eor	r1, r1
	hundreds = passData[9];
	tens = passData[10];
	ones = passData[11];
	hundreds = hundreds - '0';
	tens= tens - '0';
	ones = ones - '0';
    1364:	90 0f       	add	r25, r16
	
	denTime = hundreds * 100 +tens * 10 + ones;	// Shifts hundreds place value into time variable.
    1366:	90 53       	subi	r25, 0x30	; 48
    1368:	90 93 94 02 	sts	0x0294, r25
	
	printStr("Denaturing time is "); //send App
    136c:	80 eb       	ldi	r24, 0xB0	; 176
    136e:	91 e0       	ldi	r25, 0x01	; 1
    1370:	0e 94 7f 0b 	call	0x16fe	; 0x16fe <printStr>
	hundreds = hundreds + '0';
	tens= tens + '0';
	ones = ones + '0';
	uart_putchar(hundreds);
    1374:	8e 2d       	mov	r24, r14
    1376:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <uart_putchar>
	uart_putchar(tens);
    137a:	8f 2d       	mov	r24, r15
    137c:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <uart_putchar>
	uart_putchar(ones);
    1380:	80 2f       	mov	r24, r16
    1382:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <uart_putchar>
	uart_putchar('\n');
    1386:	8a e0       	ldi	r24, 0x0A	; 10
    1388:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <uart_putchar>
    138c:	2f ef       	ldi	r18, 0xFF	; 255
    138e:	87 ea       	ldi	r24, 0xA7	; 167
    1390:	91 e6       	ldi	r25, 0x61	; 97
    1392:	21 50       	subi	r18, 0x01	; 1
    1394:	80 40       	sbci	r24, 0x00	; 0
    1396:	90 40       	sbci	r25, 0x00	; 0
    1398:	e1 f7       	brne	.-8      	; 0x1392 <set_PCR+0x1ac>
    139a:	00 c0       	rjmp	.+0      	; 0x139c <set_PCR+0x1b6>
    139c:	00 00       	nop
	_delay_ms(2000);
	
	
	// Set Annealing Temperature:
	hundreds = passData[12];
    139e:	ec 84       	ldd	r14, Y+12	; 0x0c
	tens = passData[13];
    13a0:	fd 84       	ldd	r15, Y+13	; 0x0d
	ones = passData[14];
    13a2:	0e 85       	ldd	r16, Y+14	; 0x0e
	hundreds = hundreds - '0';
    13a4:	80 ed       	ldi	r24, 0xD0	; 208
    13a6:	8e 0d       	add	r24, r14
	tens= tens - '0';
    13a8:	9f 2d       	mov	r25, r15
    13aa:	99 0f       	add	r25, r25
	ones = ones - '0';
	
	annTemp = hundreds * 100 +tens * 10 + ones;	// Shifts hundreds place value into time variable.
    13ac:	90 56       	subi	r25, 0x60	; 96
    13ae:	29 2f       	mov	r18, r25
    13b0:	22 0f       	add	r18, r18
    13b2:	22 0f       	add	r18, r18
    13b4:	92 0f       	add	r25, r18
    13b6:	81 9f       	mul	r24, r17
    13b8:	90 0d       	add	r25, r0
    13ba:	11 24       	eor	r1, r1
	hundreds = passData[12];
	tens = passData[13];
	ones = passData[14];
	hundreds = hundreds - '0';
	tens= tens - '0';
	ones = ones - '0';
    13bc:	90 0f       	add	r25, r16
	
	annTemp = hundreds * 100 +tens * 10 + ones;	// Shifts hundreds place value into time variable.
    13be:	90 53       	subi	r25, 0x30	; 48
    13c0:	90 93 b1 02 	sts	0x02B1, r25
	
	printStr("Annealing temp is "); //send App
    13c4:	84 ec       	ldi	r24, 0xC4	; 196
    13c6:	91 e0       	ldi	r25, 0x01	; 1
    13c8:	0e 94 7f 0b 	call	0x16fe	; 0x16fe <printStr>
	hundreds = hundreds + '0';
	tens= tens + '0';
	ones = ones + '0';
    uart_putchar(hundreds);
    13cc:	8e 2d       	mov	r24, r14
    13ce:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <uart_putchar>
    uart_putchar(tens);
    13d2:	8f 2d       	mov	r24, r15
    13d4:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <uart_putchar>
    uart_putchar(ones);
    13d8:	80 2f       	mov	r24, r16
    13da:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <uart_putchar>
    uart_putchar('\n');
    13de:	8a e0       	ldi	r24, 0x0A	; 10
    13e0:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <uart_putchar>
    13e4:	2f ef       	ldi	r18, 0xFF	; 255
    13e6:	87 ea       	ldi	r24, 0xA7	; 167
    13e8:	91 e6       	ldi	r25, 0x61	; 97
    13ea:	21 50       	subi	r18, 0x01	; 1
    13ec:	80 40       	sbci	r24, 0x00	; 0
    13ee:	90 40       	sbci	r25, 0x00	; 0
    13f0:	e1 f7       	brne	.-8      	; 0x13ea <set_PCR+0x204>
    13f2:	00 c0       	rjmp	.+0      	; 0x13f4 <set_PCR+0x20e>
    13f4:	00 00       	nop
    _delay_ms(2000);
	
	
	// Set Annealing Time:
	hundreds = passData[15];
    13f6:	ef 84       	ldd	r14, Y+15	; 0x0f
	tens = passData[16];
    13f8:	f8 88       	ldd	r15, Y+16	; 0x10
	ones = passData[17];
    13fa:	09 89       	ldd	r16, Y+17	; 0x11
	hundreds = hundreds - '0';
    13fc:	80 ed       	ldi	r24, 0xD0	; 208
    13fe:	8e 0d       	add	r24, r14
	tens= tens - '0';
    1400:	9f 2d       	mov	r25, r15
    1402:	99 0f       	add	r25, r25
	ones = ones - '0';
	
	annTime = hundreds * 100 +tens * 10 + ones;	// Shifts hundreds place value into time variable.
    1404:	90 56       	subi	r25, 0x60	; 96
    1406:	29 2f       	mov	r18, r25
    1408:	22 0f       	add	r18, r18
    140a:	22 0f       	add	r18, r18
    140c:	92 0f       	add	r25, r18
    140e:	81 9f       	mul	r24, r17
    1410:	90 0d       	add	r25, r0
    1412:	11 24       	eor	r1, r1
	hundreds = passData[15];
	tens = passData[16];
	ones = passData[17];
	hundreds = hundreds - '0';
	tens= tens - '0';
	ones = ones - '0';
    1414:	90 0f       	add	r25, r16
	
	annTime = hundreds * 100 +tens * 10 + ones;	// Shifts hundreds place value into time variable.
    1416:	90 53       	subi	r25, 0x30	; 48
    1418:	90 93 b5 02 	sts	0x02B5, r25

	printStr("Annealing time is "); //send App
    141c:	87 ed       	ldi	r24, 0xD7	; 215
    141e:	91 e0       	ldi	r25, 0x01	; 1
    1420:	0e 94 7f 0b 	call	0x16fe	; 0x16fe <printStr>
	hundreds = hundreds + '0';
	tens= tens + '0';
	ones = ones + '0';
    uart_putchar(hundreds);
    1424:	8e 2d       	mov	r24, r14
    1426:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <uart_putchar>
    uart_putchar(tens);
    142a:	8f 2d       	mov	r24, r15
    142c:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <uart_putchar>
    uart_putchar(ones);
    1430:	80 2f       	mov	r24, r16
    1432:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <uart_putchar>
    uart_putchar('\n');
    1436:	8a e0       	ldi	r24, 0x0A	; 10
    1438:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <uart_putchar>
    143c:	2f ef       	ldi	r18, 0xFF	; 255
    143e:	87 ea       	ldi	r24, 0xA7	; 167
    1440:	91 e6       	ldi	r25, 0x61	; 97
    1442:	21 50       	subi	r18, 0x01	; 1
    1444:	80 40       	sbci	r24, 0x00	; 0
    1446:	90 40       	sbci	r25, 0x00	; 0
    1448:	e1 f7       	brne	.-8      	; 0x1442 <set_PCR+0x25c>
    144a:	00 c0       	rjmp	.+0      	; 0x144c <set_PCR+0x266>
    144c:	00 00       	nop
    _delay_ms(2000);
	
	
	// Set Elongation Temperature:
	hundreds = passData[18];
    144e:	ea 88       	ldd	r14, Y+18	; 0x12
	tens = passData[19];
    1450:	fb 88       	ldd	r15, Y+19	; 0x13
	ones = passData[20];
    1452:	0c 89       	ldd	r16, Y+20	; 0x14
	hundreds = hundreds - '0';
    1454:	80 ed       	ldi	r24, 0xD0	; 208
    1456:	8e 0d       	add	r24, r14
	tens= tens - '0';
    1458:	9f 2d       	mov	r25, r15
    145a:	99 0f       	add	r25, r25
	ones = ones - '0';
	
	eloTemp = hundreds * 100 +tens * 10 + ones;	// Shifts hundreds place value into time variable.
    145c:	90 56       	subi	r25, 0x60	; 96
    145e:	29 2f       	mov	r18, r25
    1460:	22 0f       	add	r18, r18
    1462:	22 0f       	add	r18, r18
    1464:	92 0f       	add	r25, r18
    1466:	81 9f       	mul	r24, r17
    1468:	90 0d       	add	r25, r0
    146a:	11 24       	eor	r1, r1
	hundreds = passData[18];
	tens = passData[19];
	ones = passData[20];
	hundreds = hundreds - '0';
	tens= tens - '0';
	ones = ones - '0';
    146c:	90 0f       	add	r25, r16
	
	eloTemp = hundreds * 100 +tens * 10 + ones;	// Shifts hundreds place value into time variable.
    146e:	90 53       	subi	r25, 0x30	; 48
    1470:	90 93 b4 02 	sts	0x02B4, r25
	
	printStr("Elongation temp is "); //send App
    1474:	8a ee       	ldi	r24, 0xEA	; 234
    1476:	91 e0       	ldi	r25, 0x01	; 1
    1478:	0e 94 7f 0b 	call	0x16fe	; 0x16fe <printStr>
	hundreds = hundreds + '0';
	tens= tens + '0';
	ones = ones + '0';
    uart_putchar(hundreds);
    147c:	8e 2d       	mov	r24, r14
    147e:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <uart_putchar>
    uart_putchar(tens);
    1482:	8f 2d       	mov	r24, r15
    1484:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <uart_putchar>
    uart_putchar(ones);
    1488:	80 2f       	mov	r24, r16
    148a:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <uart_putchar>
    uart_putchar('\n');
    148e:	8a e0       	ldi	r24, 0x0A	; 10
    1490:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <uart_putchar>
    1494:	2f ef       	ldi	r18, 0xFF	; 255
    1496:	87 ea       	ldi	r24, 0xA7	; 167
    1498:	91 e6       	ldi	r25, 0x61	; 97
    149a:	21 50       	subi	r18, 0x01	; 1
    149c:	80 40       	sbci	r24, 0x00	; 0
    149e:	90 40       	sbci	r25, 0x00	; 0
    14a0:	e1 f7       	brne	.-8      	; 0x149a <set_PCR+0x2b4>
    14a2:	00 c0       	rjmp	.+0      	; 0x14a4 <set_PCR+0x2be>
    14a4:	00 00       	nop
    _delay_ms(2000);
	
	
	// Set Elongation Time:
	hundreds = passData[21];
    14a6:	fd 88       	ldd	r15, Y+21	; 0x15
	tens = passData[22];
    14a8:	0e 89       	ldd	r16, Y+22	; 0x16
	ones = passData[23];
    14aa:	cf 89       	ldd	r28, Y+23	; 0x17
	hundreds = hundreds - '0';
    14ac:	80 ed       	ldi	r24, 0xD0	; 208
    14ae:	8f 0d       	add	r24, r15
	tens= tens - '0';
    14b0:	90 2f       	mov	r25, r16
    14b2:	99 0f       	add	r25, r25
	ones = ones - '0';
	
	eloTime = hundreds * 100 +tens * 10 + ones;	// Shifts hundreds place value into time variable.
    14b4:	90 56       	subi	r25, 0x60	; 96
    14b6:	29 2f       	mov	r18, r25
    14b8:	22 0f       	add	r18, r18
    14ba:	22 0f       	add	r18, r18
    14bc:	92 0f       	add	r25, r18
    14be:	81 9f       	mul	r24, r17
    14c0:	90 0d       	add	r25, r0
    14c2:	11 24       	eor	r1, r1
	hundreds = passData[21];
	tens = passData[22];
	ones = passData[23];
	hundreds = hundreds - '0';
	tens= tens - '0';
	ones = ones - '0';
    14c4:	9c 0f       	add	r25, r28
	
	eloTime = hundreds * 100 +tens * 10 + ones;	// Shifts hundreds place value into time variable.
    14c6:	90 53       	subi	r25, 0x30	; 48
    14c8:	90 93 97 02 	sts	0x0297, r25
	
	printStr("Elongation time is "); //send App
    14cc:	8e ef       	ldi	r24, 0xFE	; 254
    14ce:	91 e0       	ldi	r25, 0x01	; 1
    14d0:	0e 94 7f 0b 	call	0x16fe	; 0x16fe <printStr>
	hundreds = hundreds + '0';
	tens= tens + '0';
	ones = ones + '0';
    uart_putchar(hundreds);
    14d4:	8f 2d       	mov	r24, r15
    14d6:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <uart_putchar>
    uart_putchar(tens);
    14da:	80 2f       	mov	r24, r16
    14dc:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <uart_putchar>
    uart_putchar(ones);
    14e0:	8c 2f       	mov	r24, r28
    14e2:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <uart_putchar>
    uart_putchar('\n');
    14e6:	8a e0       	ldi	r24, 0x0A	; 10
    14e8:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <uart_putchar>
    14ec:	2f ef       	ldi	r18, 0xFF	; 255
    14ee:	87 ea       	ldi	r24, 0xA7	; 167
    14f0:	91 e6       	ldi	r25, 0x61	; 97
    14f2:	21 50       	subi	r18, 0x01	; 1
    14f4:	80 40       	sbci	r24, 0x00	; 0
    14f6:	90 40       	sbci	r25, 0x00	; 0
    14f8:	e1 f7       	brne	.-8      	; 0x14f2 <set_PCR+0x30c>
    14fa:	00 c0       	rjmp	.+0      	; 0x14fc <set_PCR+0x316>
    14fc:	00 00       	nop
	uart_putchar(ones);
	uart_putchar('\n');
	_delay_ms(2000);
	
	*/
}
    14fe:	df 91       	pop	r29
    1500:	cf 91       	pop	r28
    1502:	1f 91       	pop	r17
    1504:	0f 91       	pop	r16
    1506:	ff 90       	pop	r15
    1508:	ef 90       	pop	r14
    150a:	08 95       	ret

0000150c <runPCR>:
		*/
	}
	return getInput;
}	

void runPCR(void){
    150c:	cf 93       	push	r28
    150e:	df 93       	push	r29
	int cycle = 0;
    1510:	c0 e0       	ldi	r28, 0x00	; 0
    1512:	d0 e0       	ldi	r29, 0x00	; 0
	
	//for (cycle=0; cycle < 30; cycle++)
	while(cycle < 30)
	{
		printStr("In cycle ");
    1514:	82 e1       	ldi	r24, 0x12	; 18
    1516:	92 e0       	ldi	r25, 0x02	; 2
    1518:	0e 94 7f 0b 	call	0x16fe	; 0x16fe <printStr>
		int_to_char(cycle);
    151c:	ce 01       	movw	r24, r28
    151e:	0e 94 95 0b 	call	0x172a	; 0x172a <int_to_char>
		uart_putchar('\n');
    1522:	8a e0       	ldi	r24, 0x0A	; 10
    1524:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <uart_putchar>
		//printStr("In run PCR \n"); //send
		holdAtTemp(denTemp,denTime);
    1528:	60 91 94 02 	lds	r22, 0x0294
    152c:	80 91 b2 02 	lds	r24, 0x02B2
    1530:	70 e0       	ldi	r23, 0x00	; 0
    1532:	90 e0       	ldi	r25, 0x00	; 0
    1534:	0e 94 02 07 	call	0xe04	; 0xe04 <holdAtTemp>
		//printStr("passed den \n"); //send
		holdAtTemp(annTemp,annTime);
    1538:	60 91 b5 02 	lds	r22, 0x02B5
    153c:	80 91 b1 02 	lds	r24, 0x02B1
    1540:	70 e0       	ldi	r23, 0x00	; 0
    1542:	90 e0       	ldi	r25, 0x00	; 0
    1544:	0e 94 02 07 	call	0xe04	; 0xe04 <holdAtTemp>
		//printStr("passed ann \n"); //send
		holdAtTemp(eloTemp,eloTime);
    1548:	60 91 97 02 	lds	r22, 0x0297
    154c:	80 91 b4 02 	lds	r24, 0x02B4
    1550:	70 e0       	ldi	r23, 0x00	; 0
    1552:	90 e0       	ldi	r25, 0x00	; 0
    1554:	0e 94 02 07 	call	0xe04	; 0xe04 <holdAtTemp>
		//printStr("passed elo \n"); //send
		cycle = cycle + 1;
    1558:	21 96       	adiw	r28, 0x01	; 1

void runPCR(void){
	int cycle = 0;
	
	//for (cycle=0; cycle < 30; cycle++)
	while(cycle < 30)
    155a:	ce 31       	cpi	r28, 0x1E	; 30
    155c:	d1 05       	cpc	r29, r1
    155e:	d1 f6       	brne	.-76     	; 0x1514 <runPCR+0x8>
		//printStr("passed ann \n"); //send
		holdAtTemp(eloTemp,eloTime);
		//printStr("passed elo \n"); //send
		cycle = cycle + 1;
	}
    1560:	df 91       	pop	r29
    1562:	cf 91       	pop	r28
    1564:	08 95       	ret

00001566 <set_init>:
}



void set_init(void){
	CPU_PRESCALE(CPU_16MHz);	//Set up UART
    1566:	e1 e6       	ldi	r30, 0x61	; 97
    1568:	f0 e0       	ldi	r31, 0x00	; 0
    156a:	80 e8       	ldi	r24, 0x80	; 128
    156c:	80 83       	st	Z, r24
    156e:	10 82       	st	Z, r1
	timer_init();
    1570:	0e 94 2f 0b 	call	0x165e	; 0x165e <timer_init>
	pwm_init();
    1574:	0e 94 48 0b 	call	0x1690	; 0x1690 <pwm_init>
	adc_init();
    1578:	0e 94 75 00 	call	0xea	; 0xea <adc_init>
	uart_init();
    157c:	0e 94 55 0b 	call	0x16aa	; 0x16aa <uart_init>
	while (clear != '\0')		// Takes in all 18 values send and confirms that the values are correct:
	{
		clear = uart_getchar();
	}
	//uart_init2();
	h_c_init(); 
    1580:	0e 94 fb 06 	call	0xdf6	; 0xdf6 <h_c_init>
	
	PORTB = 0b00000000; // Sets all PB pin values low.
    1584:	15 b8       	out	0x05, r1	; 5
	PORTF = 0b00000000; // Sets all PF pins low.
    1586:	11 ba       	out	0x11, r1	; 17
	PORTD = 0b00000000; // Sets all PD pins low.
    1588:	1b b8       	out	0x0b, r1	; 11
	sei(); // Enable interrupts
    158a:	78 94       	sei
    158c:	08 95       	ret

0000158e <main>:
///////////////////////////////////	Begin Main	/////////////////////////////////////////////

int main(void)
{
	// Initializations:
	set_init();
    158e:	0e 94 b3 0a 	call	0x1566	; 0x1566 <set_init>
	printStr("Welcome to PCR \n");
    1592:	8c e1       	ldi	r24, 0x1C	; 28
    1594:	92 e0       	ldi	r25, 0x02	; 2
    1596:	0e 94 7f 0b 	call	0x16fe	; 0x16fe <printStr>
    159a:	2f ef       	ldi	r18, 0xFF	; 255
    159c:	83 ed       	ldi	r24, 0xD3	; 211
    159e:	90 e3       	ldi	r25, 0x30	; 48
    15a0:	21 50       	subi	r18, 0x01	; 1
    15a2:	80 40       	sbci	r24, 0x00	; 0
    15a4:	90 40       	sbci	r25, 0x00	; 0
    15a6:	e1 f7       	brne	.-8      	; 0x15a0 <main+0x12>
    15a8:	00 c0       	rjmp	.+0      	; 0x15aa <main+0x1c>
    15aa:	00 00       	nop
	_delay_ms(1000);
	
	//isBatLow();
	char input;
	ValidateData();
    15ac:	0e 94 8c 08 	call	0x1118	; 0x1118 <ValidateData>
	input = 1;	// for testing bypass user input.
    15b0:	c1 e0       	ldi	r28, 0x01	; 1
			set_PCR();
			printStr("PCR has been set. \n"); //send 
			_delay_ms(1000);
			signed char valid;
			valid = '~';
			UDR1 = valid;
    15b2:	0f 2e       	mov	r0, r31
    15b4:	fe ec       	ldi	r31, 0xCE	; 206
    15b6:	ef 2e       	mov	r14, r31
    15b8:	f1 2c       	mov	r15, r1
    15ba:	f0 2d       	mov	r31, r0
    15bc:	de e7       	ldi	r29, 0x7E	; 126
			uart_putchar (valid);
			printStr("sent ~ \n");
			_delay_ms(1000);
			input = 2;	// for testing bypass user input.
    15be:	02 e0       	ldi	r16, 0x02	; 2
			printStr("Run PCR \n"); //send
			
			runPCR();
			//input = run;
			printStr("PCR finished \n"); //send
			input = 10;	// for testing bypass user input.
    15c0:	1a e0       	ldi	r17, 0x0A	; 10
		/* Control Structure:
		1. Set PCR
		2. Run PCR
		*/

		printStr("Press 1 to set PCR \n"); //send 
    15c2:	8d e2       	ldi	r24, 0x2D	; 45
    15c4:	92 e0       	ldi	r25, 0x02	; 2
    15c6:	0e 94 7f 0b 	call	0x16fe	; 0x16fe <printStr>
    15ca:	ef ef       	ldi	r30, 0xFF	; 255
    15cc:	f7 ea       	ldi	r31, 0xA7	; 167
    15ce:	21 e6       	ldi	r18, 0x61	; 97
    15d0:	e1 50       	subi	r30, 0x01	; 1
    15d2:	f0 40       	sbci	r31, 0x00	; 0
    15d4:	20 40       	sbci	r18, 0x00	; 0
    15d6:	e1 f7       	brne	.-8      	; 0x15d0 <main+0x42>
    15d8:	00 c0       	rjmp	.+0      	; 0x15da <main+0x4c>
    15da:	00 00       	nop
		_delay_ms(2000);
			
		printStr("Press 2 to run PCR \n"); //send
    15dc:	82 e4       	ldi	r24, 0x42	; 66
    15de:	92 e0       	ldi	r25, 0x02	; 2
    15e0:	0e 94 7f 0b 	call	0x16fe	; 0x16fe <printStr>
    15e4:	8f ef       	ldi	r24, 0xFF	; 255
    15e6:	97 ea       	ldi	r25, 0xA7	; 167
    15e8:	e1 e6       	ldi	r30, 0x61	; 97
    15ea:	81 50       	subi	r24, 0x01	; 1
    15ec:	90 40       	sbci	r25, 0x00	; 0
    15ee:	e0 40       	sbci	r30, 0x00	; 0
    15f0:	e1 f7       	brne	.-8      	; 0x15ea <main+0x5c>
    15f2:	00 c0       	rjmp	.+0      	; 0x15f4 <main+0x66>
    15f4:	00 00       	nop
		//_delay_ms(5000);
		//input= input -'0';		// Convert to char to int
		
		
		
		switch ( input ) {
    15f6:	c1 30       	cpi	r28, 0x01	; 1
    15f8:	19 f0       	breq	.+6      	; 0x1600 <main+0x72>
    15fa:	c2 30       	cpi	r28, 0x02	; 2
    15fc:	21 f1       	breq	.+72     	; 0x1646 <main+0xb8>
    15fe:	e1 cf       	rjmp	.-62     	; 0x15c2 <main+0x34>
			case 1:
			//ValidateData();
			set_PCR();
    1600:	0e 94 f3 08 	call	0x11e6	; 0x11e6 <set_PCR>
			printStr("PCR has been set. \n"); //send 
    1604:	87 e5       	ldi	r24, 0x57	; 87
    1606:	92 e0       	ldi	r25, 0x02	; 2
    1608:	0e 94 7f 0b 	call	0x16fe	; 0x16fe <printStr>
    160c:	ff ef       	ldi	r31, 0xFF	; 255
    160e:	23 ed       	ldi	r18, 0xD3	; 211
    1610:	80 e3       	ldi	r24, 0x30	; 48
    1612:	f1 50       	subi	r31, 0x01	; 1
    1614:	20 40       	sbci	r18, 0x00	; 0
    1616:	80 40       	sbci	r24, 0x00	; 0
    1618:	e1 f7       	brne	.-8      	; 0x1612 <main+0x84>
    161a:	00 c0       	rjmp	.+0      	; 0x161c <main+0x8e>
    161c:	00 00       	nop
			_delay_ms(1000);
			signed char valid;
			valid = '~';
			UDR1 = valid;
    161e:	f7 01       	movw	r30, r14
    1620:	d0 83       	st	Z, r29
			uart_putchar (valid);
    1622:	8d 2f       	mov	r24, r29
    1624:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <uart_putchar>
			printStr("sent ~ \n");
    1628:	8b e6       	ldi	r24, 0x6B	; 107
    162a:	92 e0       	ldi	r25, 0x02	; 2
    162c:	0e 94 7f 0b 	call	0x16fe	; 0x16fe <printStr>
    1630:	ff ef       	ldi	r31, 0xFF	; 255
    1632:	23 ed       	ldi	r18, 0xD3	; 211
    1634:	80 e3       	ldi	r24, 0x30	; 48
    1636:	f1 50       	subi	r31, 0x01	; 1
    1638:	20 40       	sbci	r18, 0x00	; 0
    163a:	80 40       	sbci	r24, 0x00	; 0
    163c:	e1 f7       	brne	.-8      	; 0x1636 <main+0xa8>
    163e:	00 c0       	rjmp	.+0      	; 0x1640 <main+0xb2>
    1640:	00 00       	nop
			_delay_ms(1000);
			input = 2;	// for testing bypass user input.
    1642:	c0 2f       	mov	r28, r16
			break;
    1644:	be cf       	rjmp	.-132    	; 0x15c2 <main+0x34>
			
			case 2:
			
			printStr("Run PCR \n"); //send
    1646:	84 e7       	ldi	r24, 0x74	; 116
    1648:	92 e0       	ldi	r25, 0x02	; 2
    164a:	0e 94 7f 0b 	call	0x16fe	; 0x16fe <printStr>
			
			runPCR();
    164e:	0e 94 86 0a 	call	0x150c	; 0x150c <runPCR>
			//input = run;
			printStr("PCR finished \n"); //send
    1652:	8e e7       	ldi	r24, 0x7E	; 126
    1654:	92 e0       	ldi	r25, 0x02	; 2
    1656:	0e 94 7f 0b 	call	0x16fe	; 0x16fe <printStr>
			input = 10;	// for testing bypass user input.
    165a:	c1 2f       	mov	r28, r17
			break;
    165c:	b2 cf       	rjmp	.-156    	; 0x15c2 <main+0x34>

0000165e <timer_init>:
		COM1C0: Compare Output Mode for Channel C
		WGM11: Waveform Generation Mode
		WGM10: Waveform Generation Mode
	*/
		
	TCCR1A |= 0x00;	//Setting TCCR1A Mode to CTC. Since bit 0 (WGM10), and bit1 (WGM11) are set to zero for both CTC setting we can set TCCR0A = 0000 0000
    165e:	e0 e8       	ldi	r30, 0x80	; 128
    1660:	f0 e0       	ldi	r31, 0x00	; 0
    1662:	80 81       	ld	r24, Z
    1664:	80 83       	st	Z, r24
		100 = CPU/256
		101 = CPU/1024
		110 = External clock source on Tn pin. Clock on falling edge
		111 = External clock source on Tn pin. Clock on rising edge
	*/
	TCCR1B |= ((1<<CS12)|(1<<WGM12)); //Setting TCCR1B initial value to 256 prescaler & setting CTC output mode (ATMEGA32U4 datasheet p.133, p.331 respectively). TCCR1B = 0000 1010
    1666:	e1 e8       	ldi	r30, 0x81	; 129
    1668:	f0 e0       	ldi	r31, 0x00	; 0
    166a:	80 81       	ld	r24, Z
    166c:	8c 60       	ori	r24, 0x0C	; 12
    166e:	80 83       	st	Z, r24
		OCIE1C: OCIEnC: Timer/Countern, Output Compare C Match Interrupt Enable
		OCIE1B: OCIEnB: Timer/Countern, Output Compare B Match Interrupt Enable
		OCIE1A: OCIEnA: Timer/Countern, Output Compare A Match Interrupt Enable
		TOIE1: TOIEn: Timer/Countern, Overflow Interrupt Enable
	*/
	TIMSK1 |=(1<<OCIE1A); // The OCIE1A bit enables interrupt flag.
    1670:	ef e6       	ldi	r30, 0x6F	; 111
    1672:	f0 e0       	ldi	r31, 0x00	; 0
    1674:	80 81       	ld	r24, Z
    1676:	82 60       	ori	r24, 0x02	; 2
    1678:	80 83       	st	Z, r24
	/*
	Output Compare Register 1A (OCR1A) value must be [0:65535], because the TCCR registers for TCCR1 are 16 bit 2^16 = 65536. 
	Calculating your count: OCR1A = (CPU_clock speed/TCCR_clock speed)-1
	*OCR1A is being set to count in milliseconds*  
	*/
	OCR1A = 31248;  //timer 1/2 second // timer compare value   8MHz/8 = 1MHZ = 1 second (out of range), and 1000 = 1ms
    167a:	80 e1       	ldi	r24, 0x10	; 16
    167c:	9a e7       	ldi	r25, 0x7A	; 122
    167e:	90 93 89 00 	sts	0x0089, r25
    1682:	80 93 88 00 	sts	0x0088, r24
	
	
	TCNT1 = 0; // Initiates the timer to count CPU cycles.
    1686:	10 92 85 00 	sts	0x0085, r1
    168a:	10 92 84 00 	sts	0x0084, r1
    168e:	08 95       	ret

00001690 <pwm_init>:
}
*/

void pwm_init(void){
	
	TCCR0A = (1<<COM0A1)|(1<<COM0A0)|(1<<WGM01)|(1<<WGM00); //Fast PWM mode, clear on compare match
    1690:	83 ec       	ldi	r24, 0xC3	; 195
    1692:	84 bd       	out	0x24, r24	; 36
	TCCR0B = (0<<WGM02)|(1<<CS02)|(0<<CS01)|(1<<CS00); // pre-scaler 1024
    1694:	85 e0       	ldi	r24, 0x05	; 5
    1696:	85 bd       	out	0x25, r24	; 37
	DDRB |= (DDRB |= (1<<PB7)); //sets PORTB Pin 7 (OCOA -- Timer/Counter0 output) as an output pin for PWM
    1698:	84 b1       	in	r24, 0x04	; 4
    169a:	80 68       	ori	r24, 0x80	; 128
    169c:	84 b9       	out	0x04, r24	; 4
    169e:	94 b1       	in	r25, 0x04	; 4
    16a0:	89 2b       	or	r24, r25
    16a2:	84 b9       	out	0x04, r24	; 4
	OCR0A = 255; //default output to 0% duty cycle
    16a4:	8f ef       	ldi	r24, 0xFF	; 255
    16a6:	87 bd       	out	0x27, r24	; 39
    16a8:	08 95       	ret

000016aa <uart_init>:
consists of setting the baud rate, setting frame format and enabling the Transmitter or the Receiver depending
on the usage.
*/
void uart_init(void){
	// Set Baud Rate:
	UBRR1H = (uint8_t)(BAUD_PRESCALLER>>8);
    16aa:	10 92 cd 00 	sts	0x00CD, r1
	UBRR1L = (uint8_t)(BAUD_PRESCALLER);
    16ae:	87 e6       	ldi	r24, 0x67	; 103
    16b0:	80 93 cc 00 	sts	0x00CC, r24
	
	//USART Control and Status Register A – UCSR1A   ***Do not need to maniplulate****
	//UCSR1A = ((0<<RXC1)|(0<<TXC1)|(0<<UDRE1)|(0<<FE1)|(0<<DOR1)|(0<<UPE1)|(0<<U2X1)|(0<<MPCM1))
	
	//USART Control and Status Register B – UCSR1B	
	UCSR1B = ((0<<RXCIE1)|(0<<TXCIE1)|(0<<UDRIE1)|(1<<RXEN1)|(1<<TXEN1)|(0<<UCSZ12)|(0<<RXB81)|(0<<TXB81)); // Enable transmit and receive  
    16b4:	88 e1       	ldi	r24, 0x18	; 24
    16b6:	80 93 c9 00 	sts	0x00C9, r24
	
	//USART Control and Status Register C – UCSR1C
	UCSR1C = ((0<<UMSEL11)|(0<<UMSEL10)|(0<<UPM11)|(0<<UPM10)|(0<<USBS1)|(1<<UCSZ11)|(1<<UCSZ10)|(0<<UCPOL1)); // asynchronous, no parity, 1 stop, 8 data, transmitted rising edge & received falling
    16ba:	86 e0       	ldi	r24, 0x06	; 6
    16bc:	80 93 ca 00 	sts	0x00CA, r24
    16c0:	e6 eb       	ldi	r30, 0xB6	; 182
    16c2:	f2 e0       	ldi	r31, 0x02	; 2
    16c4:	20 e1       	ldi	r18, 0x10	; 16
    16c6:	33 e0       	ldi	r19, 0x03	; 3
	
	// buffer configure to all zeros:
	int i;
	for (i =0; i<90; i++)
	{
		buffer[i]='0';
    16c8:	80 e3       	ldi	r24, 0x30	; 48
    16ca:	81 93       	st	Z+, r24
	//USART Control and Status Register D – UCSR1D   ***Do not need to maniplulate****
	//UCSR1D = ((0<<CTSEN)|(0<<RTSEN));
	
	// buffer configure to all zeros:
	int i;
	for (i =0; i<90; i++)
    16cc:	e2 17       	cp	r30, r18
    16ce:	f3 07       	cpc	r31, r19
    16d0:	e1 f7       	brne	.-8      	; 0x16ca <uart_init+0x20>
	{
		buffer[i]='0';
	}
}
    16d2:	08 95       	ret

000016d4 <uart_putchar>:

// Transmit a byte, after check to make sure line is clear:
void uart_putchar(unsigned char data)
{
 while (!(UCSR1A & (1 << UDRE1))); //UDRE1: USART Data Register Empty
    16d4:	e8 ec       	ldi	r30, 0xC8	; 200
    16d6:	f0 e0       	ldi	r31, 0x00	; 0
    16d8:	90 81       	ld	r25, Z
    16da:	95 ff       	sbrs	r25, 5
    16dc:	fd cf       	rjmp	.-6      	; 0x16d8 <uart_putchar+0x4>
 UDR1 = data;
    16de:	80 93 ce 00 	sts	0x00CE, r24
    16e2:	08 95       	ret

000016e4 <uart_getchar>:
}

// Receive a byte, after checking to make sure there is a byte available:
unsigned char uart_getchar(void)
{
       while(!(UCSR1A & (1<<RXC1))); // RXC1: USART Receive Complete
    16e4:	e8 ec       	ldi	r30, 0xC8	; 200
    16e6:	f0 e0       	ldi	r31, 0x00	; 0
    16e8:	80 81       	ld	r24, Z
    16ea:	88 23       	and	r24, r24
    16ec:	ec f7       	brge	.-6      	; 0x16e8 <uart_getchar+0x4>
       DDRD |= (1<<6);
    16ee:	56 9a       	sbi	0x0a, 6	; 10
       PORTD ^= (1<<6);
    16f0:	9b b1       	in	r25, 0x0b	; 11
    16f2:	80 e4       	ldi	r24, 0x40	; 64
    16f4:	89 27       	eor	r24, r25
    16f6:	8b b9       	out	0x0b, r24	; 11
       return UDR1;
    16f8:	80 91 ce 00 	lds	r24, 0x00CE
}
    16fc:	08 95       	ret

000016fe <printStr>:

//send a string of characters
void printStr(char* data){
    16fe:	0f 93       	push	r16
    1700:	1f 93       	push	r17
    1702:	cf 93       	push	r28
    1704:	fc 01       	movw	r30, r24

	uint8_t i=0;
	//send each character until we hit the end of the string
	while(data[i] != '\0'){
    1706:	80 81       	ld	r24, Z
    1708:	88 23       	and	r24, r24
    170a:	59 f0       	breq	.+22     	; 0x1722 <printStr+0x24>
    170c:	8f 01       	movw	r16, r30
    170e:	c0 e0       	ldi	r28, 0x00	; 0
		uart_putchar(data[i]);
    1710:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <uart_putchar>
		i++;
    1714:	cf 5f       	subi	r28, 0xFF	; 255
//send a string of characters
void printStr(char* data){

	uint8_t i=0;
	//send each character until we hit the end of the string
	while(data[i] != '\0'){
    1716:	f8 01       	movw	r30, r16
    1718:	ec 0f       	add	r30, r28
    171a:	f1 1d       	adc	r31, r1
    171c:	80 81       	ld	r24, Z
    171e:	81 11       	cpse	r24, r1
    1720:	f7 cf       	rjmp	.-18     	; 0x1710 <printStr+0x12>
		uart_putchar(data[i]);
		i++;
	}
}
    1722:	cf 91       	pop	r28
    1724:	1f 91       	pop	r17
    1726:	0f 91       	pop	r16
    1728:	08 95       	ret

0000172a <int_to_char>:

void int_to_char(int in){
    172a:	cf 93       	push	r28
    172c:	df 93       	push	r29
    172e:	9c 01       	movw	r18, r24
	char ones, tens, huns;
	int temp1;
	int temp2;
	int temp3;
	temp1 = in/100;
    1730:	64 e6       	ldi	r22, 0x64	; 100
    1732:	70 e0       	ldi	r23, 0x00	; 0
    1734:	0e 94 fc 0d 	call	0x1bf8	; 0x1bf8 <__divmodhi4>
    1738:	ab 01       	movw	r20, r22
	huns = (char)temp1;
	huns = huns + '0';
	temp2 = (in-temp1*100)/10;
    173a:	6c e9       	ldi	r22, 0x9C	; 156
    173c:	64 03       	mulsu	r22, r20
    173e:	e0 01       	movw	r28, r0
    1740:	65 9f       	mul	r22, r21
    1742:	d0 0d       	add	r29, r0
    1744:	11 24       	eor	r1, r1
    1746:	c2 0f       	add	r28, r18
    1748:	d3 1f       	adc	r29, r19
    174a:	ce 01       	movw	r24, r28
    174c:	6a e0       	ldi	r22, 0x0A	; 10
    174e:	70 e0       	ldi	r23, 0x00	; 0
    1750:	0e 94 fc 0d 	call	0x1bf8	; 0x1bf8 <__divmodhi4>
    1754:	d6 2f       	mov	r29, r22
	tens = (char)temp2 + '0';
	temp3 = (in-temp1*100-temp2*10);
	ones = (char)temp3 + '0';
	
	uart_putchar(huns);
    1756:	80 e3       	ldi	r24, 0x30	; 48
    1758:	84 0f       	add	r24, r20
    175a:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <uart_putchar>
	uart_putchar(tens);
    175e:	80 e3       	ldi	r24, 0x30	; 48
    1760:	8d 0f       	add	r24, r29
    1762:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <uart_putchar>
	temp1 = in/100;
	huns = (char)temp1;
	huns = huns + '0';
	temp2 = (in-temp1*100)/10;
	tens = (char)temp2 + '0';
	temp3 = (in-temp1*100-temp2*10);
    1766:	8c 2f       	mov	r24, r28
    1768:	9a e0       	ldi	r25, 0x0A	; 10
    176a:	d9 9f       	mul	r29, r25
    176c:	80 19       	sub	r24, r0
    176e:	11 24       	eor	r1, r1
	ones = (char)temp3 + '0';
	
	uart_putchar(huns);
	uart_putchar(tens);
	uart_putchar(ones);
    1770:	80 5d       	subi	r24, 0xD0	; 208
    1772:	0e 94 6a 0b 	call	0x16d4	; 0x16d4 <uart_putchar>
	//uart_putchar('\n');
    1776:	df 91       	pop	r29
    1778:	cf 91       	pop	r28
    177a:	08 95       	ret

0000177c <__subsf3>:
    177c:	50 58       	subi	r21, 0x80	; 128

0000177e <__addsf3>:
    177e:	bb 27       	eor	r27, r27
    1780:	aa 27       	eor	r26, r26
    1782:	0e 94 d6 0b 	call	0x17ac	; 0x17ac <__addsf3x>
    1786:	0c 94 50 0d 	jmp	0x1aa0	; 0x1aa0 <__fp_round>
    178a:	0e 94 42 0d 	call	0x1a84	; 0x1a84 <__fp_pscA>
    178e:	38 f0       	brcs	.+14     	; 0x179e <__addsf3+0x20>
    1790:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <__fp_pscB>
    1794:	20 f0       	brcs	.+8      	; 0x179e <__addsf3+0x20>
    1796:	39 f4       	brne	.+14     	; 0x17a6 <__addsf3+0x28>
    1798:	9f 3f       	cpi	r25, 0xFF	; 255
    179a:	19 f4       	brne	.+6      	; 0x17a2 <__addsf3+0x24>
    179c:	26 f4       	brtc	.+8      	; 0x17a6 <__addsf3+0x28>
    179e:	0c 94 3f 0d 	jmp	0x1a7e	; 0x1a7e <__fp_nan>
    17a2:	0e f4       	brtc	.+2      	; 0x17a6 <__addsf3+0x28>
    17a4:	e0 95       	com	r30
    17a6:	e7 fb       	bst	r30, 7
    17a8:	0c 94 39 0d 	jmp	0x1a72	; 0x1a72 <__fp_inf>

000017ac <__addsf3x>:
    17ac:	e9 2f       	mov	r30, r25
    17ae:	0e 94 61 0d 	call	0x1ac2	; 0x1ac2 <__fp_split3>
    17b2:	58 f3       	brcs	.-42     	; 0x178a <__addsf3+0xc>
    17b4:	ba 17       	cp	r27, r26
    17b6:	62 07       	cpc	r22, r18
    17b8:	73 07       	cpc	r23, r19
    17ba:	84 07       	cpc	r24, r20
    17bc:	95 07       	cpc	r25, r21
    17be:	20 f0       	brcs	.+8      	; 0x17c8 <__addsf3x+0x1c>
    17c0:	79 f4       	brne	.+30     	; 0x17e0 <__addsf3x+0x34>
    17c2:	a6 f5       	brtc	.+104    	; 0x182c <__addsf3x+0x80>
    17c4:	0c 94 83 0d 	jmp	0x1b06	; 0x1b06 <__fp_zero>
    17c8:	0e f4       	brtc	.+2      	; 0x17cc <__addsf3x+0x20>
    17ca:	e0 95       	com	r30
    17cc:	0b 2e       	mov	r0, r27
    17ce:	ba 2f       	mov	r27, r26
    17d0:	a0 2d       	mov	r26, r0
    17d2:	0b 01       	movw	r0, r22
    17d4:	b9 01       	movw	r22, r18
    17d6:	90 01       	movw	r18, r0
    17d8:	0c 01       	movw	r0, r24
    17da:	ca 01       	movw	r24, r20
    17dc:	a0 01       	movw	r20, r0
    17de:	11 24       	eor	r1, r1
    17e0:	ff 27       	eor	r31, r31
    17e2:	59 1b       	sub	r21, r25
    17e4:	99 f0       	breq	.+38     	; 0x180c <__addsf3x+0x60>
    17e6:	59 3f       	cpi	r21, 0xF9	; 249
    17e8:	50 f4       	brcc	.+20     	; 0x17fe <__addsf3x+0x52>
    17ea:	50 3e       	cpi	r21, 0xE0	; 224
    17ec:	68 f1       	brcs	.+90     	; 0x1848 <__addsf3x+0x9c>
    17ee:	1a 16       	cp	r1, r26
    17f0:	f0 40       	sbci	r31, 0x00	; 0
    17f2:	a2 2f       	mov	r26, r18
    17f4:	23 2f       	mov	r18, r19
    17f6:	34 2f       	mov	r19, r20
    17f8:	44 27       	eor	r20, r20
    17fa:	58 5f       	subi	r21, 0xF8	; 248
    17fc:	f3 cf       	rjmp	.-26     	; 0x17e4 <__addsf3x+0x38>
    17fe:	46 95       	lsr	r20
    1800:	37 95       	ror	r19
    1802:	27 95       	ror	r18
    1804:	a7 95       	ror	r26
    1806:	f0 40       	sbci	r31, 0x00	; 0
    1808:	53 95       	inc	r21
    180a:	c9 f7       	brne	.-14     	; 0x17fe <__addsf3x+0x52>
    180c:	7e f4       	brtc	.+30     	; 0x182c <__addsf3x+0x80>
    180e:	1f 16       	cp	r1, r31
    1810:	ba 0b       	sbc	r27, r26
    1812:	62 0b       	sbc	r22, r18
    1814:	73 0b       	sbc	r23, r19
    1816:	84 0b       	sbc	r24, r20
    1818:	ba f0       	brmi	.+46     	; 0x1848 <__addsf3x+0x9c>
    181a:	91 50       	subi	r25, 0x01	; 1
    181c:	a1 f0       	breq	.+40     	; 0x1846 <__addsf3x+0x9a>
    181e:	ff 0f       	add	r31, r31
    1820:	bb 1f       	adc	r27, r27
    1822:	66 1f       	adc	r22, r22
    1824:	77 1f       	adc	r23, r23
    1826:	88 1f       	adc	r24, r24
    1828:	c2 f7       	brpl	.-16     	; 0x181a <__addsf3x+0x6e>
    182a:	0e c0       	rjmp	.+28     	; 0x1848 <__addsf3x+0x9c>
    182c:	ba 0f       	add	r27, r26
    182e:	62 1f       	adc	r22, r18
    1830:	73 1f       	adc	r23, r19
    1832:	84 1f       	adc	r24, r20
    1834:	48 f4       	brcc	.+18     	; 0x1848 <__addsf3x+0x9c>
    1836:	87 95       	ror	r24
    1838:	77 95       	ror	r23
    183a:	67 95       	ror	r22
    183c:	b7 95       	ror	r27
    183e:	f7 95       	ror	r31
    1840:	9e 3f       	cpi	r25, 0xFE	; 254
    1842:	08 f0       	brcs	.+2      	; 0x1846 <__addsf3x+0x9a>
    1844:	b0 cf       	rjmp	.-160    	; 0x17a6 <__addsf3+0x28>
    1846:	93 95       	inc	r25
    1848:	88 0f       	add	r24, r24
    184a:	08 f0       	brcs	.+2      	; 0x184e <__addsf3x+0xa2>
    184c:	99 27       	eor	r25, r25
    184e:	ee 0f       	add	r30, r30
    1850:	97 95       	ror	r25
    1852:	87 95       	ror	r24
    1854:	08 95       	ret

00001856 <__cmpsf2>:
    1856:	0e 94 15 0d 	call	0x1a2a	; 0x1a2a <__fp_cmp>
    185a:	08 f4       	brcc	.+2      	; 0x185e <__cmpsf2+0x8>
    185c:	81 e0       	ldi	r24, 0x01	; 1
    185e:	08 95       	ret

00001860 <__divsf3>:
    1860:	0e 94 44 0c 	call	0x1888	; 0x1888 <__divsf3x>
    1864:	0c 94 50 0d 	jmp	0x1aa0	; 0x1aa0 <__fp_round>
    1868:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <__fp_pscB>
    186c:	58 f0       	brcs	.+22     	; 0x1884 <__divsf3+0x24>
    186e:	0e 94 42 0d 	call	0x1a84	; 0x1a84 <__fp_pscA>
    1872:	40 f0       	brcs	.+16     	; 0x1884 <__divsf3+0x24>
    1874:	29 f4       	brne	.+10     	; 0x1880 <__divsf3+0x20>
    1876:	5f 3f       	cpi	r21, 0xFF	; 255
    1878:	29 f0       	breq	.+10     	; 0x1884 <__divsf3+0x24>
    187a:	0c 94 39 0d 	jmp	0x1a72	; 0x1a72 <__fp_inf>
    187e:	51 11       	cpse	r21, r1
    1880:	0c 94 84 0d 	jmp	0x1b08	; 0x1b08 <__fp_szero>
    1884:	0c 94 3f 0d 	jmp	0x1a7e	; 0x1a7e <__fp_nan>

00001888 <__divsf3x>:
    1888:	0e 94 61 0d 	call	0x1ac2	; 0x1ac2 <__fp_split3>
    188c:	68 f3       	brcs	.-38     	; 0x1868 <__divsf3+0x8>

0000188e <__divsf3_pse>:
    188e:	99 23       	and	r25, r25
    1890:	b1 f3       	breq	.-20     	; 0x187e <__divsf3+0x1e>
    1892:	55 23       	and	r21, r21
    1894:	91 f3       	breq	.-28     	; 0x187a <__divsf3+0x1a>
    1896:	95 1b       	sub	r25, r21
    1898:	55 0b       	sbc	r21, r21
    189a:	bb 27       	eor	r27, r27
    189c:	aa 27       	eor	r26, r26
    189e:	62 17       	cp	r22, r18
    18a0:	73 07       	cpc	r23, r19
    18a2:	84 07       	cpc	r24, r20
    18a4:	38 f0       	brcs	.+14     	; 0x18b4 <__divsf3_pse+0x26>
    18a6:	9f 5f       	subi	r25, 0xFF	; 255
    18a8:	5f 4f       	sbci	r21, 0xFF	; 255
    18aa:	22 0f       	add	r18, r18
    18ac:	33 1f       	adc	r19, r19
    18ae:	44 1f       	adc	r20, r20
    18b0:	aa 1f       	adc	r26, r26
    18b2:	a9 f3       	breq	.-22     	; 0x189e <__divsf3_pse+0x10>
    18b4:	35 d0       	rcall	.+106    	; 0x1920 <__divsf3_pse+0x92>
    18b6:	0e 2e       	mov	r0, r30
    18b8:	3a f0       	brmi	.+14     	; 0x18c8 <__divsf3_pse+0x3a>
    18ba:	e0 e8       	ldi	r30, 0x80	; 128
    18bc:	32 d0       	rcall	.+100    	; 0x1922 <__divsf3_pse+0x94>
    18be:	91 50       	subi	r25, 0x01	; 1
    18c0:	50 40       	sbci	r21, 0x00	; 0
    18c2:	e6 95       	lsr	r30
    18c4:	00 1c       	adc	r0, r0
    18c6:	ca f7       	brpl	.-14     	; 0x18ba <__divsf3_pse+0x2c>
    18c8:	2b d0       	rcall	.+86     	; 0x1920 <__divsf3_pse+0x92>
    18ca:	fe 2f       	mov	r31, r30
    18cc:	29 d0       	rcall	.+82     	; 0x1920 <__divsf3_pse+0x92>
    18ce:	66 0f       	add	r22, r22
    18d0:	77 1f       	adc	r23, r23
    18d2:	88 1f       	adc	r24, r24
    18d4:	bb 1f       	adc	r27, r27
    18d6:	26 17       	cp	r18, r22
    18d8:	37 07       	cpc	r19, r23
    18da:	48 07       	cpc	r20, r24
    18dc:	ab 07       	cpc	r26, r27
    18de:	b0 e8       	ldi	r27, 0x80	; 128
    18e0:	09 f0       	breq	.+2      	; 0x18e4 <__divsf3_pse+0x56>
    18e2:	bb 0b       	sbc	r27, r27
    18e4:	80 2d       	mov	r24, r0
    18e6:	bf 01       	movw	r22, r30
    18e8:	ff 27       	eor	r31, r31
    18ea:	93 58       	subi	r25, 0x83	; 131
    18ec:	5f 4f       	sbci	r21, 0xFF	; 255
    18ee:	3a f0       	brmi	.+14     	; 0x18fe <__divsf3_pse+0x70>
    18f0:	9e 3f       	cpi	r25, 0xFE	; 254
    18f2:	51 05       	cpc	r21, r1
    18f4:	78 f0       	brcs	.+30     	; 0x1914 <__divsf3_pse+0x86>
    18f6:	0c 94 39 0d 	jmp	0x1a72	; 0x1a72 <__fp_inf>
    18fa:	0c 94 84 0d 	jmp	0x1b08	; 0x1b08 <__fp_szero>
    18fe:	5f 3f       	cpi	r21, 0xFF	; 255
    1900:	e4 f3       	brlt	.-8      	; 0x18fa <__divsf3_pse+0x6c>
    1902:	98 3e       	cpi	r25, 0xE8	; 232
    1904:	d4 f3       	brlt	.-12     	; 0x18fa <__divsf3_pse+0x6c>
    1906:	86 95       	lsr	r24
    1908:	77 95       	ror	r23
    190a:	67 95       	ror	r22
    190c:	b7 95       	ror	r27
    190e:	f7 95       	ror	r31
    1910:	9f 5f       	subi	r25, 0xFF	; 255
    1912:	c9 f7       	brne	.-14     	; 0x1906 <__divsf3_pse+0x78>
    1914:	88 0f       	add	r24, r24
    1916:	91 1d       	adc	r25, r1
    1918:	96 95       	lsr	r25
    191a:	87 95       	ror	r24
    191c:	97 f9       	bld	r25, 7
    191e:	08 95       	ret
    1920:	e1 e0       	ldi	r30, 0x01	; 1
    1922:	66 0f       	add	r22, r22
    1924:	77 1f       	adc	r23, r23
    1926:	88 1f       	adc	r24, r24
    1928:	bb 1f       	adc	r27, r27
    192a:	62 17       	cp	r22, r18
    192c:	73 07       	cpc	r23, r19
    192e:	84 07       	cpc	r24, r20
    1930:	ba 07       	cpc	r27, r26
    1932:	20 f0       	brcs	.+8      	; 0x193c <__divsf3_pse+0xae>
    1934:	62 1b       	sub	r22, r18
    1936:	73 0b       	sbc	r23, r19
    1938:	84 0b       	sbc	r24, r20
    193a:	ba 0b       	sbc	r27, r26
    193c:	ee 1f       	adc	r30, r30
    193e:	88 f7       	brcc	.-30     	; 0x1922 <__divsf3_pse+0x94>
    1940:	e0 95       	com	r30
    1942:	08 95       	ret

00001944 <__fixsfsi>:
    1944:	0e 94 a9 0c 	call	0x1952	; 0x1952 <__fixunssfsi>
    1948:	68 94       	set
    194a:	b1 11       	cpse	r27, r1
    194c:	0c 94 84 0d 	jmp	0x1b08	; 0x1b08 <__fp_szero>
    1950:	08 95       	ret

00001952 <__fixunssfsi>:
    1952:	0e 94 69 0d 	call	0x1ad2	; 0x1ad2 <__fp_splitA>
    1956:	88 f0       	brcs	.+34     	; 0x197a <__fixunssfsi+0x28>
    1958:	9f 57       	subi	r25, 0x7F	; 127
    195a:	98 f0       	brcs	.+38     	; 0x1982 <__fixunssfsi+0x30>
    195c:	b9 2f       	mov	r27, r25
    195e:	99 27       	eor	r25, r25
    1960:	b7 51       	subi	r27, 0x17	; 23
    1962:	b0 f0       	brcs	.+44     	; 0x1990 <__fixunssfsi+0x3e>
    1964:	e1 f0       	breq	.+56     	; 0x199e <__fixunssfsi+0x4c>
    1966:	66 0f       	add	r22, r22
    1968:	77 1f       	adc	r23, r23
    196a:	88 1f       	adc	r24, r24
    196c:	99 1f       	adc	r25, r25
    196e:	1a f0       	brmi	.+6      	; 0x1976 <__fixunssfsi+0x24>
    1970:	ba 95       	dec	r27
    1972:	c9 f7       	brne	.-14     	; 0x1966 <__fixunssfsi+0x14>
    1974:	14 c0       	rjmp	.+40     	; 0x199e <__fixunssfsi+0x4c>
    1976:	b1 30       	cpi	r27, 0x01	; 1
    1978:	91 f0       	breq	.+36     	; 0x199e <__fixunssfsi+0x4c>
    197a:	0e 94 83 0d 	call	0x1b06	; 0x1b06 <__fp_zero>
    197e:	b1 e0       	ldi	r27, 0x01	; 1
    1980:	08 95       	ret
    1982:	0c 94 83 0d 	jmp	0x1b06	; 0x1b06 <__fp_zero>
    1986:	67 2f       	mov	r22, r23
    1988:	78 2f       	mov	r23, r24
    198a:	88 27       	eor	r24, r24
    198c:	b8 5f       	subi	r27, 0xF8	; 248
    198e:	39 f0       	breq	.+14     	; 0x199e <__fixunssfsi+0x4c>
    1990:	b9 3f       	cpi	r27, 0xF9	; 249
    1992:	cc f3       	brlt	.-14     	; 0x1986 <__fixunssfsi+0x34>
    1994:	86 95       	lsr	r24
    1996:	77 95       	ror	r23
    1998:	67 95       	ror	r22
    199a:	b3 95       	inc	r27
    199c:	d9 f7       	brne	.-10     	; 0x1994 <__fixunssfsi+0x42>
    199e:	3e f4       	brtc	.+14     	; 0x19ae <__fixunssfsi+0x5c>
    19a0:	90 95       	com	r25
    19a2:	80 95       	com	r24
    19a4:	70 95       	com	r23
    19a6:	61 95       	neg	r22
    19a8:	7f 4f       	sbci	r23, 0xFF	; 255
    19aa:	8f 4f       	sbci	r24, 0xFF	; 255
    19ac:	9f 4f       	sbci	r25, 0xFF	; 255
    19ae:	08 95       	ret

000019b0 <__floatunsisf>:
    19b0:	e8 94       	clt
    19b2:	09 c0       	rjmp	.+18     	; 0x19c6 <__floatsisf+0x12>

000019b4 <__floatsisf>:
    19b4:	97 fb       	bst	r25, 7
    19b6:	3e f4       	brtc	.+14     	; 0x19c6 <__floatsisf+0x12>
    19b8:	90 95       	com	r25
    19ba:	80 95       	com	r24
    19bc:	70 95       	com	r23
    19be:	61 95       	neg	r22
    19c0:	7f 4f       	sbci	r23, 0xFF	; 255
    19c2:	8f 4f       	sbci	r24, 0xFF	; 255
    19c4:	9f 4f       	sbci	r25, 0xFF	; 255
    19c6:	99 23       	and	r25, r25
    19c8:	a9 f0       	breq	.+42     	; 0x19f4 <__floatsisf+0x40>
    19ca:	f9 2f       	mov	r31, r25
    19cc:	96 e9       	ldi	r25, 0x96	; 150
    19ce:	bb 27       	eor	r27, r27
    19d0:	93 95       	inc	r25
    19d2:	f6 95       	lsr	r31
    19d4:	87 95       	ror	r24
    19d6:	77 95       	ror	r23
    19d8:	67 95       	ror	r22
    19da:	b7 95       	ror	r27
    19dc:	f1 11       	cpse	r31, r1
    19de:	f8 cf       	rjmp	.-16     	; 0x19d0 <__floatsisf+0x1c>
    19e0:	fa f4       	brpl	.+62     	; 0x1a20 <__floatsisf+0x6c>
    19e2:	bb 0f       	add	r27, r27
    19e4:	11 f4       	brne	.+4      	; 0x19ea <__floatsisf+0x36>
    19e6:	60 ff       	sbrs	r22, 0
    19e8:	1b c0       	rjmp	.+54     	; 0x1a20 <__floatsisf+0x6c>
    19ea:	6f 5f       	subi	r22, 0xFF	; 255
    19ec:	7f 4f       	sbci	r23, 0xFF	; 255
    19ee:	8f 4f       	sbci	r24, 0xFF	; 255
    19f0:	9f 4f       	sbci	r25, 0xFF	; 255
    19f2:	16 c0       	rjmp	.+44     	; 0x1a20 <__floatsisf+0x6c>
    19f4:	88 23       	and	r24, r24
    19f6:	11 f0       	breq	.+4      	; 0x19fc <__floatsisf+0x48>
    19f8:	96 e9       	ldi	r25, 0x96	; 150
    19fa:	11 c0       	rjmp	.+34     	; 0x1a1e <__floatsisf+0x6a>
    19fc:	77 23       	and	r23, r23
    19fe:	21 f0       	breq	.+8      	; 0x1a08 <__floatsisf+0x54>
    1a00:	9e e8       	ldi	r25, 0x8E	; 142
    1a02:	87 2f       	mov	r24, r23
    1a04:	76 2f       	mov	r23, r22
    1a06:	05 c0       	rjmp	.+10     	; 0x1a12 <__floatsisf+0x5e>
    1a08:	66 23       	and	r22, r22
    1a0a:	71 f0       	breq	.+28     	; 0x1a28 <__floatsisf+0x74>
    1a0c:	96 e8       	ldi	r25, 0x86	; 134
    1a0e:	86 2f       	mov	r24, r22
    1a10:	70 e0       	ldi	r23, 0x00	; 0
    1a12:	60 e0       	ldi	r22, 0x00	; 0
    1a14:	2a f0       	brmi	.+10     	; 0x1a20 <__floatsisf+0x6c>
    1a16:	9a 95       	dec	r25
    1a18:	66 0f       	add	r22, r22
    1a1a:	77 1f       	adc	r23, r23
    1a1c:	88 1f       	adc	r24, r24
    1a1e:	da f7       	brpl	.-10     	; 0x1a16 <__floatsisf+0x62>
    1a20:	88 0f       	add	r24, r24
    1a22:	96 95       	lsr	r25
    1a24:	87 95       	ror	r24
    1a26:	97 f9       	bld	r25, 7
    1a28:	08 95       	ret

00001a2a <__fp_cmp>:
    1a2a:	99 0f       	add	r25, r25
    1a2c:	00 08       	sbc	r0, r0
    1a2e:	55 0f       	add	r21, r21
    1a30:	aa 0b       	sbc	r26, r26
    1a32:	e0 e8       	ldi	r30, 0x80	; 128
    1a34:	fe ef       	ldi	r31, 0xFE	; 254
    1a36:	16 16       	cp	r1, r22
    1a38:	17 06       	cpc	r1, r23
    1a3a:	e8 07       	cpc	r30, r24
    1a3c:	f9 07       	cpc	r31, r25
    1a3e:	c0 f0       	brcs	.+48     	; 0x1a70 <__fp_cmp+0x46>
    1a40:	12 16       	cp	r1, r18
    1a42:	13 06       	cpc	r1, r19
    1a44:	e4 07       	cpc	r30, r20
    1a46:	f5 07       	cpc	r31, r21
    1a48:	98 f0       	brcs	.+38     	; 0x1a70 <__fp_cmp+0x46>
    1a4a:	62 1b       	sub	r22, r18
    1a4c:	73 0b       	sbc	r23, r19
    1a4e:	84 0b       	sbc	r24, r20
    1a50:	95 0b       	sbc	r25, r21
    1a52:	39 f4       	brne	.+14     	; 0x1a62 <__fp_cmp+0x38>
    1a54:	0a 26       	eor	r0, r26
    1a56:	61 f0       	breq	.+24     	; 0x1a70 <__fp_cmp+0x46>
    1a58:	23 2b       	or	r18, r19
    1a5a:	24 2b       	or	r18, r20
    1a5c:	25 2b       	or	r18, r21
    1a5e:	21 f4       	brne	.+8      	; 0x1a68 <__fp_cmp+0x3e>
    1a60:	08 95       	ret
    1a62:	0a 26       	eor	r0, r26
    1a64:	09 f4       	brne	.+2      	; 0x1a68 <__fp_cmp+0x3e>
    1a66:	a1 40       	sbci	r26, 0x01	; 1
    1a68:	a6 95       	lsr	r26
    1a6a:	8f ef       	ldi	r24, 0xFF	; 255
    1a6c:	81 1d       	adc	r24, r1
    1a6e:	81 1d       	adc	r24, r1
    1a70:	08 95       	ret

00001a72 <__fp_inf>:
    1a72:	97 f9       	bld	r25, 7
    1a74:	9f 67       	ori	r25, 0x7F	; 127
    1a76:	80 e8       	ldi	r24, 0x80	; 128
    1a78:	70 e0       	ldi	r23, 0x00	; 0
    1a7a:	60 e0       	ldi	r22, 0x00	; 0
    1a7c:	08 95       	ret

00001a7e <__fp_nan>:
    1a7e:	9f ef       	ldi	r25, 0xFF	; 255
    1a80:	80 ec       	ldi	r24, 0xC0	; 192
    1a82:	08 95       	ret

00001a84 <__fp_pscA>:
    1a84:	00 24       	eor	r0, r0
    1a86:	0a 94       	dec	r0
    1a88:	16 16       	cp	r1, r22
    1a8a:	17 06       	cpc	r1, r23
    1a8c:	18 06       	cpc	r1, r24
    1a8e:	09 06       	cpc	r0, r25
    1a90:	08 95       	ret

00001a92 <__fp_pscB>:
    1a92:	00 24       	eor	r0, r0
    1a94:	0a 94       	dec	r0
    1a96:	12 16       	cp	r1, r18
    1a98:	13 06       	cpc	r1, r19
    1a9a:	14 06       	cpc	r1, r20
    1a9c:	05 06       	cpc	r0, r21
    1a9e:	08 95       	ret

00001aa0 <__fp_round>:
    1aa0:	09 2e       	mov	r0, r25
    1aa2:	03 94       	inc	r0
    1aa4:	00 0c       	add	r0, r0
    1aa6:	11 f4       	brne	.+4      	; 0x1aac <__fp_round+0xc>
    1aa8:	88 23       	and	r24, r24
    1aaa:	52 f0       	brmi	.+20     	; 0x1ac0 <__fp_round+0x20>
    1aac:	bb 0f       	add	r27, r27
    1aae:	40 f4       	brcc	.+16     	; 0x1ac0 <__fp_round+0x20>
    1ab0:	bf 2b       	or	r27, r31
    1ab2:	11 f4       	brne	.+4      	; 0x1ab8 <__fp_round+0x18>
    1ab4:	60 ff       	sbrs	r22, 0
    1ab6:	04 c0       	rjmp	.+8      	; 0x1ac0 <__fp_round+0x20>
    1ab8:	6f 5f       	subi	r22, 0xFF	; 255
    1aba:	7f 4f       	sbci	r23, 0xFF	; 255
    1abc:	8f 4f       	sbci	r24, 0xFF	; 255
    1abe:	9f 4f       	sbci	r25, 0xFF	; 255
    1ac0:	08 95       	ret

00001ac2 <__fp_split3>:
    1ac2:	57 fd       	sbrc	r21, 7
    1ac4:	90 58       	subi	r25, 0x80	; 128
    1ac6:	44 0f       	add	r20, r20
    1ac8:	55 1f       	adc	r21, r21
    1aca:	59 f0       	breq	.+22     	; 0x1ae2 <__fp_splitA+0x10>
    1acc:	5f 3f       	cpi	r21, 0xFF	; 255
    1ace:	71 f0       	breq	.+28     	; 0x1aec <__fp_splitA+0x1a>
    1ad0:	47 95       	ror	r20

00001ad2 <__fp_splitA>:
    1ad2:	88 0f       	add	r24, r24
    1ad4:	97 fb       	bst	r25, 7
    1ad6:	99 1f       	adc	r25, r25
    1ad8:	61 f0       	breq	.+24     	; 0x1af2 <__fp_splitA+0x20>
    1ada:	9f 3f       	cpi	r25, 0xFF	; 255
    1adc:	79 f0       	breq	.+30     	; 0x1afc <__fp_splitA+0x2a>
    1ade:	87 95       	ror	r24
    1ae0:	08 95       	ret
    1ae2:	12 16       	cp	r1, r18
    1ae4:	13 06       	cpc	r1, r19
    1ae6:	14 06       	cpc	r1, r20
    1ae8:	55 1f       	adc	r21, r21
    1aea:	f2 cf       	rjmp	.-28     	; 0x1ad0 <__fp_split3+0xe>
    1aec:	46 95       	lsr	r20
    1aee:	f1 df       	rcall	.-30     	; 0x1ad2 <__fp_splitA>
    1af0:	08 c0       	rjmp	.+16     	; 0x1b02 <__fp_splitA+0x30>
    1af2:	16 16       	cp	r1, r22
    1af4:	17 06       	cpc	r1, r23
    1af6:	18 06       	cpc	r1, r24
    1af8:	99 1f       	adc	r25, r25
    1afa:	f1 cf       	rjmp	.-30     	; 0x1ade <__fp_splitA+0xc>
    1afc:	86 95       	lsr	r24
    1afe:	71 05       	cpc	r23, r1
    1b00:	61 05       	cpc	r22, r1
    1b02:	08 94       	sec
    1b04:	08 95       	ret

00001b06 <__fp_zero>:
    1b06:	e8 94       	clt

00001b08 <__fp_szero>:
    1b08:	bb 27       	eor	r27, r27
    1b0a:	66 27       	eor	r22, r22
    1b0c:	77 27       	eor	r23, r23
    1b0e:	cb 01       	movw	r24, r22
    1b10:	97 f9       	bld	r25, 7
    1b12:	08 95       	ret

00001b14 <__gesf2>:
    1b14:	0e 94 15 0d 	call	0x1a2a	; 0x1a2a <__fp_cmp>
    1b18:	08 f4       	brcc	.+2      	; 0x1b1c <__gesf2+0x8>
    1b1a:	8f ef       	ldi	r24, 0xFF	; 255
    1b1c:	08 95       	ret

00001b1e <__mulsf3>:
    1b1e:	0e 94 a2 0d 	call	0x1b44	; 0x1b44 <__mulsf3x>
    1b22:	0c 94 50 0d 	jmp	0x1aa0	; 0x1aa0 <__fp_round>
    1b26:	0e 94 42 0d 	call	0x1a84	; 0x1a84 <__fp_pscA>
    1b2a:	38 f0       	brcs	.+14     	; 0x1b3a <__mulsf3+0x1c>
    1b2c:	0e 94 49 0d 	call	0x1a92	; 0x1a92 <__fp_pscB>
    1b30:	20 f0       	brcs	.+8      	; 0x1b3a <__mulsf3+0x1c>
    1b32:	95 23       	and	r25, r21
    1b34:	11 f0       	breq	.+4      	; 0x1b3a <__mulsf3+0x1c>
    1b36:	0c 94 39 0d 	jmp	0x1a72	; 0x1a72 <__fp_inf>
    1b3a:	0c 94 3f 0d 	jmp	0x1a7e	; 0x1a7e <__fp_nan>
    1b3e:	11 24       	eor	r1, r1
    1b40:	0c 94 84 0d 	jmp	0x1b08	; 0x1b08 <__fp_szero>

00001b44 <__mulsf3x>:
    1b44:	0e 94 61 0d 	call	0x1ac2	; 0x1ac2 <__fp_split3>
    1b48:	70 f3       	brcs	.-36     	; 0x1b26 <__mulsf3+0x8>

00001b4a <__mulsf3_pse>:
    1b4a:	95 9f       	mul	r25, r21
    1b4c:	c1 f3       	breq	.-16     	; 0x1b3e <__mulsf3+0x20>
    1b4e:	95 0f       	add	r25, r21
    1b50:	50 e0       	ldi	r21, 0x00	; 0
    1b52:	55 1f       	adc	r21, r21
    1b54:	62 9f       	mul	r22, r18
    1b56:	f0 01       	movw	r30, r0
    1b58:	72 9f       	mul	r23, r18
    1b5a:	bb 27       	eor	r27, r27
    1b5c:	f0 0d       	add	r31, r0
    1b5e:	b1 1d       	adc	r27, r1
    1b60:	63 9f       	mul	r22, r19
    1b62:	aa 27       	eor	r26, r26
    1b64:	f0 0d       	add	r31, r0
    1b66:	b1 1d       	adc	r27, r1
    1b68:	aa 1f       	adc	r26, r26
    1b6a:	64 9f       	mul	r22, r20
    1b6c:	66 27       	eor	r22, r22
    1b6e:	b0 0d       	add	r27, r0
    1b70:	a1 1d       	adc	r26, r1
    1b72:	66 1f       	adc	r22, r22
    1b74:	82 9f       	mul	r24, r18
    1b76:	22 27       	eor	r18, r18
    1b78:	b0 0d       	add	r27, r0
    1b7a:	a1 1d       	adc	r26, r1
    1b7c:	62 1f       	adc	r22, r18
    1b7e:	73 9f       	mul	r23, r19
    1b80:	b0 0d       	add	r27, r0
    1b82:	a1 1d       	adc	r26, r1
    1b84:	62 1f       	adc	r22, r18
    1b86:	83 9f       	mul	r24, r19
    1b88:	a0 0d       	add	r26, r0
    1b8a:	61 1d       	adc	r22, r1
    1b8c:	22 1f       	adc	r18, r18
    1b8e:	74 9f       	mul	r23, r20
    1b90:	33 27       	eor	r19, r19
    1b92:	a0 0d       	add	r26, r0
    1b94:	61 1d       	adc	r22, r1
    1b96:	23 1f       	adc	r18, r19
    1b98:	84 9f       	mul	r24, r20
    1b9a:	60 0d       	add	r22, r0
    1b9c:	21 1d       	adc	r18, r1
    1b9e:	82 2f       	mov	r24, r18
    1ba0:	76 2f       	mov	r23, r22
    1ba2:	6a 2f       	mov	r22, r26
    1ba4:	11 24       	eor	r1, r1
    1ba6:	9f 57       	subi	r25, 0x7F	; 127
    1ba8:	50 40       	sbci	r21, 0x00	; 0
    1baa:	9a f0       	brmi	.+38     	; 0x1bd2 <__mulsf3_pse+0x88>
    1bac:	f1 f0       	breq	.+60     	; 0x1bea <__mulsf3_pse+0xa0>
    1bae:	88 23       	and	r24, r24
    1bb0:	4a f0       	brmi	.+18     	; 0x1bc4 <__mulsf3_pse+0x7a>
    1bb2:	ee 0f       	add	r30, r30
    1bb4:	ff 1f       	adc	r31, r31
    1bb6:	bb 1f       	adc	r27, r27
    1bb8:	66 1f       	adc	r22, r22
    1bba:	77 1f       	adc	r23, r23
    1bbc:	88 1f       	adc	r24, r24
    1bbe:	91 50       	subi	r25, 0x01	; 1
    1bc0:	50 40       	sbci	r21, 0x00	; 0
    1bc2:	a9 f7       	brne	.-22     	; 0x1bae <__mulsf3_pse+0x64>
    1bc4:	9e 3f       	cpi	r25, 0xFE	; 254
    1bc6:	51 05       	cpc	r21, r1
    1bc8:	80 f0       	brcs	.+32     	; 0x1bea <__mulsf3_pse+0xa0>
    1bca:	0c 94 39 0d 	jmp	0x1a72	; 0x1a72 <__fp_inf>
    1bce:	0c 94 84 0d 	jmp	0x1b08	; 0x1b08 <__fp_szero>
    1bd2:	5f 3f       	cpi	r21, 0xFF	; 255
    1bd4:	e4 f3       	brlt	.-8      	; 0x1bce <__mulsf3_pse+0x84>
    1bd6:	98 3e       	cpi	r25, 0xE8	; 232
    1bd8:	d4 f3       	brlt	.-12     	; 0x1bce <__mulsf3_pse+0x84>
    1bda:	86 95       	lsr	r24
    1bdc:	77 95       	ror	r23
    1bde:	67 95       	ror	r22
    1be0:	b7 95       	ror	r27
    1be2:	f7 95       	ror	r31
    1be4:	e7 95       	ror	r30
    1be6:	9f 5f       	subi	r25, 0xFF	; 255
    1be8:	c1 f7       	brne	.-16     	; 0x1bda <__mulsf3_pse+0x90>
    1bea:	fe 2b       	or	r31, r30
    1bec:	88 0f       	add	r24, r24
    1bee:	91 1d       	adc	r25, r1
    1bf0:	96 95       	lsr	r25
    1bf2:	87 95       	ror	r24
    1bf4:	97 f9       	bld	r25, 7
    1bf6:	08 95       	ret

00001bf8 <__divmodhi4>:
    1bf8:	97 fb       	bst	r25, 7
    1bfa:	07 2e       	mov	r0, r23
    1bfc:	16 f4       	brtc	.+4      	; 0x1c02 <__divmodhi4+0xa>
    1bfe:	00 94       	com	r0
    1c00:	07 d0       	rcall	.+14     	; 0x1c10 <__divmodhi4_neg1>
    1c02:	77 fd       	sbrc	r23, 7
    1c04:	09 d0       	rcall	.+18     	; 0x1c18 <__divmodhi4_neg2>
    1c06:	0e 94 10 0e 	call	0x1c20	; 0x1c20 <__udivmodhi4>
    1c0a:	07 fc       	sbrc	r0, 7
    1c0c:	05 d0       	rcall	.+10     	; 0x1c18 <__divmodhi4_neg2>
    1c0e:	3e f4       	brtc	.+14     	; 0x1c1e <__divmodhi4_exit>

00001c10 <__divmodhi4_neg1>:
    1c10:	90 95       	com	r25
    1c12:	81 95       	neg	r24
    1c14:	9f 4f       	sbci	r25, 0xFF	; 255
    1c16:	08 95       	ret

00001c18 <__divmodhi4_neg2>:
    1c18:	70 95       	com	r23
    1c1a:	61 95       	neg	r22
    1c1c:	7f 4f       	sbci	r23, 0xFF	; 255

00001c1e <__divmodhi4_exit>:
    1c1e:	08 95       	ret

00001c20 <__udivmodhi4>:
    1c20:	aa 1b       	sub	r26, r26
    1c22:	bb 1b       	sub	r27, r27
    1c24:	51 e1       	ldi	r21, 0x11	; 17
    1c26:	07 c0       	rjmp	.+14     	; 0x1c36 <__udivmodhi4_ep>

00001c28 <__udivmodhi4_loop>:
    1c28:	aa 1f       	adc	r26, r26
    1c2a:	bb 1f       	adc	r27, r27
    1c2c:	a6 17       	cp	r26, r22
    1c2e:	b7 07       	cpc	r27, r23
    1c30:	10 f0       	brcs	.+4      	; 0x1c36 <__udivmodhi4_ep>
    1c32:	a6 1b       	sub	r26, r22
    1c34:	b7 0b       	sbc	r27, r23

00001c36 <__udivmodhi4_ep>:
    1c36:	88 1f       	adc	r24, r24
    1c38:	99 1f       	adc	r25, r25
    1c3a:	5a 95       	dec	r21
    1c3c:	a9 f7       	brne	.-22     	; 0x1c28 <__udivmodhi4_loop>
    1c3e:	80 95       	com	r24
    1c40:	90 95       	com	r25
    1c42:	bc 01       	movw	r22, r24
    1c44:	cd 01       	movw	r24, r26
    1c46:	08 95       	ret

00001c48 <_exit>:
    1c48:	f8 94       	cli

00001c4a <__stop_program>:
    1c4a:	ff cf       	rjmp	.-2      	; 0x1c4a <__stop_program>
